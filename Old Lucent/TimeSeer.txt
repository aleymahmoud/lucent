# ==========================================
# TimeSeer: Time Series Forecasting Application
# ==========================================

# Required libraries
library(shiny)
library(shinydashboard)
library(shinydashboardPlus)  # For enhanced dashboard components
library(shinyjs)             # For JavaScript functionality
library(shinyWidgets)        # For enhanced input widgets
library(DT)                  # For interactive tables
library(plotly)              # For interactive plots
library(shinycssloaders)     # For loading spinners

# UI Definition
ui <- dashboardPage(
  skin = "green",
  
  # ===== Header =====
  dashboardHeader(
    title = div(
      style = "white-space: normal; line-height: 1.1; padding: 7px 0;",
      span("TimeSeer", style = "font-size: 20px; font-weight: bold;"), 
      br(),
      span("Time Series Forecasting", style = "font-size: 12px;")
    ),
    titleWidth = 300
  ),
  
  # ===== Sidebar =====
  dashboardSidebar(
    width = 300,
    sidebarMenu(
      id = "sidebar",
      menuItem("Data", tabName = "data", icon = icon("database")),
      menuItem("Preprocessing", tabName = "preprocessing", icon = icon("filter")),
      menuItem("Forecast", tabName = "forecast", icon = icon("chart-line")),
      menuItem("Results", tabName = "results", icon = icon("chart-bar")),
      menuItem("Diagnostics", tabName = "diagnostics", icon = icon("stethoscope")),
      menuItem("Help", tabName = "help", icon = icon("question-circle"))
    ),
    
    # Action buttons in sidebar
    div(
      style = "padding: 15px;",
      #actionButton("go", "Run Forecast", icon = icon("play"), 
      #             class = "btn-success btn-block", 
      #             style = "margin-bottom: 10px;"),
      downloadButton("download", "Download Results", 
                     class = "btn-info btn-block")
    )
  ),
  
  # ===== Body =====
  dashboardBody(
    useShinyjs(),
    
    # Custom CSS
    tags$head(
      tags$style(HTML("
        /* General styling */
        .content-wrapper {
          background-color: #f9f9f9;
        }
        
        /* Box styling */
        .box {
          border-radius: 3px;
          box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
        }
        
        .box-header {
          border-bottom: 1px solid #f4f4f4;
        }
        
        /* Button styling */
        .btn-success {
          background-color: #00a65a !important;
          border-color: #008d4c !important;
        }
        
        .btn-info {
          background-color: #00c0ef !important;
          border-color: #1b02ad !important;
        }
        
        /* Status boxes */
        .small-box {
          border-radius: 3px;
          box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
          transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        
        .small-box:hover {
          box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
        }
        
        /* Item selector */
        .item-selector {
          background-color: white;
          padding: 15px;
          border-radius: 3px;
          border-left: 4px solid #00a65a;
          margin-bottom: 20px;
          box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
        }
        
        /* Help icon */
        .help-tooltip {
          color: #666;
          margin-left: 8px;
          cursor: pointer;
        }
      "))
    ),
    
    # Tabbed content - matching the sidebar menu
    tabItems(
      # ===== Data Tab =====
      tabItem(
        tabName = "data",
        
        # App introduction
        fluidRow(
          box(
            width = 12,
            title = "Welcome to TimeSeer",
            status = "success",
            solidHeader = TRUE,
            collapsible = TRUE,
            
            div(
              style = "display: flex; flex-wrap: wrap; gap: 20px; align-items: center;",
              
              div(
                style = "flex: 2; min-width: 300px;",
                h4("Advanced Time Series Forecasting Tool"),
                p("Upload your time series data, analyze patterns, and generate accurate forecasts with various statistical methods."),
                p("This tool supports:", style = "margin-bottom: 5px;"),
                tags$ul(
                  tags$li("Multiple forecasting methods (ARIMA, Exponential Smoothing, Prophet)"),
                  tags$li("Data preprocessing (outlier detection, missing values, aggregation)"),
                  tags$li("Interactive visualization of results"),
                  tags$li("Model diagnostics and performance metrics"),
                  tags$li("Export of forecast results")
                )
              ),
              
              div(
                style = "flex: 1; min-width: 200px; text-align: center;",
                icon("chart-line", style = "font-size: 100px; color: #00a65a; opacity: 0.2;")
              )
            )
          )
        ),
        
        # Status indicators
        fluidRow(
          valueBoxOutput("data_status_box", width = 3),
          valueBoxOutput("items_count_box", width = 3),
          valueBoxOutput("date_range_box", width = 3),
          valueBoxOutput("forecast_status_box", width = 3)
        ),
        
        # Data upload section
        fluidRow(
          box(
            width = 12,
            title = "Data Input",
            status = "primary",
            solidHeader = TRUE,
            
            div(
              style = "display: flex; flex-wrap: wrap; gap: 20px;",
              
              # Upload area
              div(
                style = "flex: 1; min-width: 300px;",
                h4("Upload Data File"),
                p("Upload a CSV or Excel file with your time series data."),
                fileInput("file", NULL,
                          accept = c(".csv", ".xlsx"),
                          buttonLabel = "Browse...",
                          placeholder = "No file selected"),
                checkboxInput("header", "File has header row", TRUE),
                div(
                  class = "alert alert-info",
                  style = "margin-top: 10px;",
                  icon("info-circle"),
                  HTML("Required format: Data with <b>Date</b>, <b>Item_ID</b>, <b>Item_Name</b>, and <b>Volume</b> columns.")
                )
              ),
              
              # Template area
              div(
                style = "flex: 1; min-width: 300px;",
                h4("Download Template"),
                p("Not sure about the format? Download our template for guidance."),
                br(),
                downloadButton("download_Tem", "Download Template", class = "btn-primary"),
                br(), br(),
                div(
                  class = "alert alert-success",
                  icon("lightbulb"),
                  "The template includes sample data you can use to test the application."
                )
              )
            )
          )
        ),
        
        # Data preview section
        fluidRow(
          box(
            width = 12,
            title = "Data Preview",
            status = "primary",
            solidHeader = TRUE,
            collapsible = TRUE,
            collapsed = FALSE,
            
            withSpinner(DTOutput("data_preview"), type = 8, color = "#00a65a")
          )
        ),
        
        # Data summary section
        fluidRow(
          tabBox(
            width = 12,
            id = "data_summary_tabs",
            
            tabPanel(
              "Summary Statistics",
              withSpinner(verbatimTextOutput("data_summary"), type = 8, color = "#00a65a")
            ),
            
            tabPanel(
              "Data Structure", 
              withSpinner(verbatimTextOutput("data_structure"), type = 8, color = "#00a65a")
            ),
            
            tabPanel(
              "Missing Values",
              withSpinner(plotOutput("missing_values_plot"), type = 8, color = "#00a65a")
            )
          )
        )
      ),
      
      # ===== Preprocessing Tab =====
      tabItem(
        tabName = "preprocessing",
        
        fluidRow(
          # Item selection box - moved to the top for better UX
          box(
            width = 12,
            title = "Select Item",
            status = "primary",
            solidHeader = TRUE,
            
            div(
              class = "item-selector",
              div(
                style = "display: flex; flex-wrap: wrap; align-items: center; gap: 15px;",
                div(
                  style = "flex: 3; min-width: 250px;",
                  selectizeInput("selectitem", "Item to Analyze:", 
                                 choices = NULL, 
                                 options = list(
                                   placeholder = "Select an item to analyze",
                                   onInitialize = I('function() { this.setValue(""); }')
                                 ))
                ),
                div(
                  style = "flex: 1; min-width: 150px; text-align: right;",
                  checkboxInput("show_all_items", "Show combined view for all items", FALSE)
                )
              )
            )
          )
        ),
        
        fluidRow(
          column(
            width = 9,
            
            # Data visualization
            box(
              width = 12,
              title = "Time Series Visualization",
              status = "primary",
              solidHeader = TRUE,
              
              div(
                style = "display: flex; justify-content: flex-end; margin-bottom: 10px;",
                div(
                  style = "display: flex; align-items: center; gap: 10px;",
                  selectInput("plot_type", "Plot Type:", 
                              choices = c("Line", "Bar", "Point", "Area"),
                              selected = "Line",
                              width = "120px"),
                  checkboxInput("show_outliers", "Highlight Outliers", TRUE)
                )
              ),
              
              withSpinner(plotlyOutput("preprocessing_plot", height = "300px"), type = 8, color = "#00a65a")
            ),
            
            # Tabbed preprocessing options
            tabBox(
              id = "preprocessing_tabs",
              width = 12,
              
              # Tab 1: Data Cleaning
              tabPanel(
                "Data Cleaning",
                
                fluidRow(
                  column(
                    width = 6,
                    h4("Handle Missing Values"),
                    selectInput("missing_treatment", "Method:",
                                choices = c(
                                  "Linear Interpolation" = "linear",
                                  "Forward Fill" = "ffill",
                                  "Backward Fill" = "bfill",
                                  "Mean Fill" = "mean",
                                  "Median Fill" = "median",
                                  "Remove Rows" = "remove"
                                ),
                                selected = "linear"),
                    actionButton("apply_missing", "Apply", class = "btn-primary")
                  ),
                  column(
                    width = 6,
                    h4("Handle Duplicates"),
                    selectInput("duplicate_handling", "Method:",
                                choices = c(
                                  "Keep All" = "keep",
                                  "Keep First" = "first",
                                  "Keep Last" = "last",
                                  "Aggregate Sum" = "sum",
                                  "Aggregate Mean" = "mean"
                                ),
                                selected = "keep"),
                    actionButton("apply_duplicates", "Apply", class = "btn-primary")
                  )
                ),
                
                hr(),
                
                fluidRow(
                  column(
                    width = 12,
                    h4("Handle Outliers"),
                    
                    fluidRow(
                      column(
                        width = 4,
                        selectInput("outlier_method", "Detection Method:",
                                    choices = c(
                                      "IQR Method" = "iqr",
                                      "Z-Score" = "zscore",
                                      "GESD Test" = "gesd"
                                    ),
                                    selected = "iqr")
                      ),
                      column(
                        width = 4,
                        sliderInput("outlier_threshold", "Threshold:",
                                    min = 1.5, max = 5, value = 3, step = 0.1)
                      ),
                      column(
                        width = 4,
                        selectInput("outlier_action", "Action:",
                                    choices = c(
                                      "Keep Outliers" = "keep",
                                      "Remove Outliers" = "remove",
                                      "Replace with Mean" = "mean",
                                      "Replace with Median" = "median",
                                      "Winsorize" = "winsorize"
                                    ),
                                    selected = "keep")
                      )
                    ),
                    
                    actionButton("apply_outliers", "Apply", class = "btn-primary")
                  )
                )
              ),
              
              # Tab 2: Time Aggregation
              tabPanel(
                "Time Aggregation",
                
                fluidRow(
                  column(
                    width = 6,
                    selectInput("data_aggregation", "Aggregation Level:",
                                choices = c(
                                  "None" = "none",
                                  "Daily to Weekly" = "weekly",
                                  "Daily to Monthly" = "monthly",
                                  "Weekly to Monthly" = "weekly_to_monthly",
                                  "Custom" = "custom"
                                ),
                                selected = "none"),
                    conditionalPanel(
                      condition = "input.data_aggregation === 'custom'",
                      numericInput("agg_period", "Custom Period (Days):", 7, min = 1, max = 365)
                    )
                  ),
                  column(
                    width = 6,
                    selectInput("agg_method", "Aggregation Method:",
                                choices = c(
                                  "Sum" = "sum",
                                  "Mean" = "mean",
                                  "Median" = "median",
                                  "Maximum" = "max",
                                  "Minimum" = "min"
                                ),
                                selected = "sum")
                  )
                ),
                
                withSpinner(plotlyOutput("aggregation_preview", height = "250px"), type = 8, color = "#00a65a"),
                
                div(
                  style = "margin-top: 15px; text-align: center;",
                  actionButton("apply_aggregation", "Apply Aggregation", class = "btn-primary")
                )
              ),
              
              # Tab 3: Transformation & Seasonality
              tabPanel(
                "Transformation & Seasonality",
                
                fluidRow(
                  column(
                    width = 6,
                    h4("Data Transformation"),
                    
                    selectInput("transform_method", "Transformation Method:",
                                choices = c(
                                  "None" = "none",
                                  "Log" = "log",
                                  "Square Root" = "sqrt",
                                  "Box-Cox" = "boxcox",
                                  "Standardize (Z-score)" = "zscore",
                                  "Min-Max Scaling" = "minmax"
                                ),
                                selected = "none"),
                    conditionalPanel(
                      condition = "input.transform_method === 'boxcox'",
                      sliderInput("lambda", "Lambda Value:", -2, 2, 0, step = 0.1)
                    ),
                    
                    actionButton("apply_transform", "Apply Transformation", class = "btn-primary")
                  ),
                  column(
                    width = 6,
                    h4("Seasonal Adjustment"),
                    
                    selectInput("seasonality_method", "Seasonal Adjustment Method:",
                                choices = c(
                                  "None" = "none",
                                  "Seasonal Decomposition" = "decompose",
                                  "STL Decomposition" = "stl",
                                  "Moving Average" = "ma"
                                ),
                                selected = "none"),
                    checkboxInput("adjust_seasonality", "Remove Seasonality", FALSE),
                    conditionalPanel(
                      condition = "input.adjust_seasonality === true",
                      radioButtons("seasonal_type", "Seasonal Type:", 
                                   choices = c("Additive", "Multiplicative"),
                                   selected = "Additive")
                    ),
                    
                    actionButton("apply_seasonal", "Apply Seasonal Adjustment", class = "btn-primary")
                  )
                ),
                
                withSpinner(plotlyOutput("transformation_preview", height = "250px"), type = 8, color = "#00a65a")
              )
            )
          ),
          
          # Right sidebar with preprocessing status and actions
          column(
            width = 3,
            
            # Preprocessing status box
            box(
              width = 12,
              title = "Current Data Status",
              status = "success",
              solidHeader = TRUE,
              
              uiOutput("data_status_indicators"),
              
              hr(),
              
              h4("Applied Preprocessing:"),
              verbatimTextOutput("preprocessing_summary"),
              
              hr(),
              
              # Action buttons
              div(
                style = "display: flex; flex-direction: column; gap: 10px;",
                actionButton("apply_preprocessing", "Apply All Changes", 
                             icon = icon("check-circle"), 
                             class = "btn-success btn-block"),
                actionButton("reset_preprocessing", "Reset to Original", 
                             icon = icon("undo"), 
                             class = "btn-warning btn-block"),
                downloadButton("download_preprocessed", "Download Processed Data", 
                               class = "btn-info btn-block")
              )
            ),
            
            # Data statistics box
            box(
              width = 12,
              title = "Statistics",
              status = "primary",
              solidHeader = TRUE,
              
              valueBoxOutput("stats_n_obs", width = 12),
              valueBoxOutput("stats_mean", width = 12),
              valueBoxOutput("stats_stdev", width = 12),
              valueBoxOutput("stats_missing", width = 12),
              valueBoxOutput("stats_outliers", width = 12)
            )
          )
        )
      ),
      
      # ===== Forecast Tab =====
      tabItem(
        tabName = "forecast",
        
        fluidRow(
          # Selected item indicator for consistency
          box(
            width = 12,
            title = "Select Item for Forecasting",
            status = "primary",
            solidHeader = TRUE,
            
            div(
              class = "item-selector",
              div(
                style = "display: flex; flex-wrap: wrap; align-items: center; gap: 15px;",
                div(
                  style = "flex: 3; min-width: 250px;",
                  selectizeInput("forecast_item", "Item to Forecast:", 
                                 choices = NULL, 
                                 options = list(
                                   placeholder = "Select an item to forecast",
                                   onInitialize = I('function() { this.setValue(""); }')
                                 ))
                ),
                div(
                  style = "flex: 1; min-width: 150px; text-align: right;",
                  checkboxInput("forecast_all_items", "Forecast all items", FALSE)
                )
              )
            )
          )
        ),
        
        fluidRow(
          column(
            width = 8,
            
            # Forecast method selection
            box(
              width = 12,
              title = "Forecasting Method",
              status = "primary",
              solidHeader = TRUE,
              
              fluidRow(
                column(
                  width = 12,
                  div(
                    style = "display: flex; flex-wrap: wrap; gap: 10px; justify-content: space-between;",
                    
                    # ARIMA method card
                    div(
                      style = "flex: 1; min-width: 250px; border: 1px solid #ddd; border-radius: 5px; padding: 15px; background-color: #f9f9f9;",
                      div(
                        style = "display: flex; align-items: center; margin-bottom: 10px;",
                        radioButtons("method", NULL, choiceNames = list(
                          HTML("<strong>ARIMA</strong>")
                        ), choiceValues = list("ARIMA"), inline = TRUE, selected = "ARIMA"),
                        div(
                          style = "margin-left: auto;",
                          icon("info-circle", class = "help-tooltip", 
                               "data-toggle" = "tooltip", 
                               "title" = "Auto-Regressive Integrated Moving Average model for time series forecasting")
                        )
                      ),
                      p("Best for: Stationary data with trend and seasonal patterns."),
                      p("Features: Auto-detects parameters, handles differencing, seasonal components.")
                    ),
                    
                    # Exponential Smoothing method card
                    div(
                      style = "flex: 1; min-width: 250px; border: 1px solid #ddd; border-radius: 5px; padding: 15px; background-color: #f9f9f9;",
                      div(
                        style = "display: flex; align-items: center; margin-bottom: 10px;",
                        radioButtons("method", NULL, choiceNames = list(
                          HTML("<strong>Exponential Smoothing</strong>")
                        ), choiceValues = list("Exponential Smoothing"), inline = TRUE),
                        div(
                          style = "margin-left: auto;",
                          icon("info-circle", class = "help-tooltip", 
                               "data-toggle" = "tooltip", 
                               "title" = "ETS models with adjustable error, trend, and seasonal components")
                        )
                      ),
                      p("Best for: Data with clear trend and seasonal patterns."),
                      p("Features: Handles additive/multiplicative patterns, robust to outliers.")
                    ),
                    
                    # Prophet method card
                    div(
                      style = "flex: 1; min-width: 250px; border: 1px solid #ddd; border-radius: 5px; padding: 15px; background-color: #f9f9f9;",
                      div(
                        style = "display: flex; align-items: center; margin-bottom: 10px;",
                        radioButtons("method", NULL, choiceNames = list(
                          HTML("<strong>Prophet</strong>")
                        ), choiceValues = list("Prophet"), inline = TRUE),
                        div(
                          style = "margin-left: auto;",
                          icon("info-circle", class = "help-tooltip", 
                               "data-toggle" = "tooltip", 
                               "title" = "Facebook's Prophet algorithm for business time series forecasting")
                        )
                      ),
                      p("Best for: Business time series with multiple seasonality patterns."),
                      p("Features: Handles holidays, outliers, missing data, and trend changes.")
                    )
                  )
                )
              ),
              
              hr(),
              
              # Method-specific settings (shown/hidden based on selection)
              conditionalPanel(
                condition = "input.method === 'ARIMA'",
                h4("ARIMA Settings"),
                fluidRow(
                  column(
                    width = 6,
                    checkboxInput("auto_arima", "Use auto.arima (recommended)", TRUE)
                  ),
                  column(
                    width = 6,
                    conditionalPanel(
                      condition = "!input.auto_arima",
                      div(
                        style = "display: flex; gap: 10px;",
                        numericInput("p_value", "p:", 1, 0, 5, width = "80px"),
                        numericInput("d_value", "d:", 1, 0, 2, width = "80px"),
                        numericInput("q_value", "q:", 1, 0, 5, width = "80px")
                      )
                    )
                  )
                ),
                fluidRow(
                  column(
                    width = 12,
                    conditionalPanel(
                      condition = "!input.auto_arima",
                      checkboxInput("seasonal_arima", "Include seasonal component", TRUE),
                      conditionalPanel(
                        condition = "input.seasonal_arima",
                        div(
                          style = "display: flex; gap: 10px;",
                          numericInput("P_value", "P:", 1, 0, 2, width = "80px"),
                          numericInput("D_value", "D:", 1, 0, 1, width = "80px"),
                          numericInput("Q_value", "Q:", 1, 0, 2, width = "80px"),
                          numericInput("S_value", "Period:", 12, 1, 52, width = "80px")
                        )
                      )
                    )
                  )
                )
              ),
              
              conditionalPanel(
                condition = "input.method === 'Exponential Smoothing'",
                h4("Exponential Smoothing Settings"),
                fluidRow(
                  column(
                    width = 6,
                    checkboxInput("auto_ets", "Use automatic ETS (recommended)", TRUE)
                  ),
                  column(
                    width = 6,
                    conditionalPanel(
                      condition = "!input.auto_ets",
                      selectInput("ets_model", "ETS Model:",
                                  choices = c(
                                    "Simple Exponential Smoothing" = "ANN",
                                    "Holt's Linear Trend" = "AAN",
                                    "Additive Holt-Winters" = "AAA",
                                    "Multiplicative Holt-Winters" = "MAM"
                                  ),
                                  selected = "AAA")
                    )
                  )
                ),
                conditionalPanel(
                  condition = "!input.auto_ets",
                  sliderInput("alpha", "Alpha (level):", 0.01, 0.99, 0.2, step = 0.01),
                  sliderInput("beta", "Beta (trend):", 0.01, 0.99, 0.1, step = 0.01),
                  sliderInput("gamma", "Gamma (seasonal):", 0.01, 0.99, 0.1, step = 0.01)
                )
              ),
              
              conditionalPanel(
                condition = "input.method === 'Prophet'",
                h4("Prophet Settings"),
                fluidRow(
                  column(
                    width = 6,
                    sliderInput("changepoint_prior", "Changepoint Prior Scale:", 0.01, 0.5, 0.05, step = 0.01),
                    checkboxInput("yearly_seasonality", "Yearly Seasonality", TRUE),
                    checkboxInput("weekly_seasonality", "Weekly Seasonality", TRUE)
                  ),
                  column(
                    width = 6,
                    sliderInput("seasonality_prior", "Seasonality Prior Scale:", 0.01, 10, 1, step = 0.1),
                    checkboxInput("daily_seasonality", "Daily Seasonality", FALSE),
                    checkboxInput("include_holidays", "Include Holidays", FALSE),
                    conditionalPanel(
                      condition = "input.include_holidays",
                      selectInput("holiday_country", "Country:", 
                                  choices = c("US", "UK", "Canada", "Germany", "Brazil", "India", "China"),
                                  selected = "US")
                    )
                  )
                )
              )
            ),
            
            # Forecast preview
            box(
              width = 12,
              title = "Forecast Preview",
              status = "primary",
              solidHeader = TRUE,
              
              withSpinner(plotlyOutput("forecast_preview", height = "300px"), type = 8, color = "#00a65a"),
              
              div(
                style = "margin-top: 15px; text-align: right;",
                actionButton("update_preview", "Update Preview", 
                             icon = icon("sync"), 
                             class = "btn-info")
              )
            )
          ),
          
          # Forecast settings
          column(
            width = 4,
            
            # Basic forecast settings
            box(
              width = 12,
              title = "Forecast Settings",
              status = "primary",
              solidHeader = TRUE,
              
              numericInput("h_value", "Forecast Horizon (periods):",
                           value = 7, min = 1, max = 365),
              
              selectInput("frequency", "Data Frequency:",
                          choices = c("Daily" = 1,
                                      "Weekly" = 7,
                                      "Monthly" = 30,
                                      "Quarterly" = 4,
                                      "Yearly" = 1),
                          selected = 7),
              
              checkboxInput("auto_frequency", "Auto-detect frequency", TRUE),
              
              hr(),
              
              checkboxInput("use_prediction_intervals", "Show prediction intervals", TRUE),
              
              conditionalPanel(
                condition = "input.use_prediction_intervals",
                sliderInput("prediction_interval", "Confidence Level:",
                            min = 50, max = 99, value = 80, step = 5)
              ),
              
              hr(),
              
              h4("Advanced Settings"),
              
              checkboxInput("enable_cv", "Enable Cross-Validation", FALSE),
              
              conditionalPanel(
                condition = "input.enable_cv",
                numericInput("cv_folds", "Number of Folds:",
                             value = 3, min = 2, max = 10),
                selectInput("cv_method", "CV Method:",
                            choices = c(
                              "Rolling Window" = "rolling", 
                              "Expanding Window" = "expanding"
                            ),
                            selected = "rolling")
              ),
              
              checkboxGroupInput("metrics", "Performance Metrics:",
                                 choices = c("MAE", "RMSE", "MAPE"),
                                 selected = c("MAE", "RMSE", "MAPE"))
            ),
            
            # Run forecast box
            box(
              width = 12,
              title = "Run Forecast",
              status = "success",
              solidHeader = TRUE,
              
              checkboxInput("batch_forecast", "Batch process all items", FALSE),
              
              conditionalPanel(
                condition = "input.batch_forecast",
                sliderInput("parallel_cores", "Parallel Processing Cores:",
                            min = 1, max = 8, value = 2, step = 1)
              ),
              
              div(
                style = "text-align: center; margin-top: 20px;",
                actionButton("go", "Run Forecast", 
                             icon = icon("play"), 
                             class = "btn-success btn-lg",
                             style = "width: 100%; padding: 10px;")
              ),
              
              div(
                style = "margin-top: 15px;",
                div(
                  class = "alert alert-info",
                  icon("info-circle"),
                  "Forecast generation may take some time depending on the data size and method selected."
                )
              )
            )
          )
        )
      ),
      
      # ===== Results Tab =====
      tabItem(
        tabName = "results",
        
        fluidRow(
          # Item selection for results
          box(
            width = 12,
            title = "Select Item to View Results",
            status = "primary",
            solidHeader = TRUE,
            
            div(
              class = "item-selector",
              div(
                style = "display: flex; flex-wrap: wrap; align-items: center; gap: 15px;",
                div(
                  style = "flex: 3; min-width: 250px;",
                  selectizeInput("results_item", "Item:", 
                                 choices = NULL, 
                                 options = list(
                                   placeholder = "Select an item to view results",
                                   onInitialize = I('function() { this.setValue(""); }')
                                 ))
                ),
                div(
                  style = "flex: 1; min-width: 150px; text-align: right;",
                  downloadButton("download", "Download Results", class = "btn-info")
                )
              )
            )
          )
        ),
        
        # Performance metrics
        fluidRow(
          valueBoxOutput("mae_box", width = 4),
          valueBoxOutput("rmse_box", width = 4),
          valueBoxOutput("mape_box", width = 4)
        ),
        
        # Main results content
        fluidRow(
          column(
            width = 8,
            
            # Forecast plot
            box(
              width = 12,
              title = "Forecast Results",
              status = "primary",
              solidHeader = TRUE,
              
              div(
                style = "display: flex; justify-content: flex-end; margin-bottom: 10px;",
                div(
                  style = "display: flex; align-items: center; gap: 10px;",
                  selectInput("results_plot_type", "Plot Type:", 
                              choices = c("Line", "Line with Points", "Area"),
                              selected = "Line",
                              width = "150px"),
                  checkboxInput("show_intervals", "Show Prediction Intervals", TRUE)
                )
              ),
              
              withSpinner(plotlyOutput("results_plot", height = "350px"), type = 8, color = "#00a65a")
            ),
            
            # Forecast details tabbed view
            tabBox(
              id = "results_tabs",
              width = 12,
              
              tabPanel(
                "Data Table",
                div(
                  style = "display: flex; justify-content: flex-end; margin-bottom: 10px;",
                  div(
                    style = "display: flex; align-items: center; gap: 10px;",
                    selectInput("table_view", "View:", 
                                choices = c("Forecast Only", "Historical + Forecast", "Full Data"),
                                selected = "Forecast Only",
                                width = "200px")
                  )
                ),
                withSpinner(DTOutput("results_table"), type = 8, color = "#00a65a")
              ),
              
              tabPanel(
                "Forecast Statistics",
                withSpinner(verbatimTextOutput("forecast_stats"), type = 8, color = "#00a65a")
              ),
              
              tabPanel(
                "Decomposition",
                withSpinner(plotlyOutput("decomposition_plot", height = "500px"), type = 8, color = "#00a65a")
              )
            )
          ),
          
          column(
            width = 4,
            
            # Model summary
            box(
              width = 12,
              title = "Model Summary",
              status = "primary",
              solidHeader = TRUE,
              
              div(
                id = "model_summary_container",
                withSpinner(verbatimTextOutput("model_summary"), type = 8, color = "#00a65a")
              ),
              
              hr(),
              
              div(
                class = "alert alert-info",
                icon("info-circle"),
                "This summary displays the key parameters of the fitted model."
              )
            ),
            
            # Cross-validation results (if enabled)
            conditionalPanel(
              condition = "input.enable_cv === true",
              box(
                width = 12,
                title = "Cross-Validation Results",
                status = "primary",
                solidHeader = TRUE,
                
                withSpinner(DTOutput("cv_results"), type = 8, color = "#00a65a"),
                
                conditionalPanel(
                  condition = "output.cv_results",
                  div(
                    style = "margin-top: 15px;",
                    plotlyOutput("cv_plot", height = "200px")
                  )
                )
              )
            ),
            
            # Additional actions
            box(
              width = 12,
              title = "Actions",
              status = "primary",
              solidHeader = TRUE,
              
              div(
                style = "display: flex; flex-direction: column; gap: 10px;",
                actionButton("export_report", "Export Full Report", 
                             icon = icon("file-pdf"), 
                             class = "btn-primary btn-block"),
                actionButton("rerun_forecast", "Adjust & Re-run Forecast", 
                             icon = icon("sync"), 
                             class = "btn-warning btn-block"),
                actionButton("compare_models", "Compare Models", 
                             icon = icon("balance-scale"), 
                             class = "btn-info btn-block")
              ),
              
              hr(),
              
              selectInput("export_format", "Export Format:",
                          choices = c(
                            "Excel (.xlsx)" = "xlsx",
                            "CSV (.csv)" = "csv",
                            "R Data (.rds)" = "rds"
                          ),
                          selected = "xlsx")
            )
          )
        )
      ),
      
      # ===== Diagnostics Tab =====
      tabItem(
        tabName = "diagnostics",
        
        fluidRow(
          # Item selection for diagnostics
          box(
            width = 12,
            title = "Select Item for Diagnostics",
            status = "primary",
            solidHeader = TRUE,
            
            div(
              class = "item-selector",
              div(
                style = "display: flex; flex-wrap: wrap; align-items: center; gap: 15px;",
                div(
                  style = "flex: 3; min-width: 250px;",
                  selectizeInput("diagnostics_item", "Item:", 
                                 choices = NULL, 
                                 options = list(
                                   placeholder = "Select an item to analyze",
                                   onInitialize = I('function() { this.setValue(""); }')
                                 ))
                ),
                div(
                  style = "flex: 1; min-width: 150px; text-align: right;",
                  selectInput("diagnostics_model", "Model:", 
                              choices = NULL)
                )
              )
            )
          )
        ),
        
        fluidRow(
          column(
            width = 8,
            
            # Residual analysis
            box(
              width = 12,
              title = "Residual Analysis",
              status = "primary",
              solidHeader = TRUE,
              
              fluidRow(
                column(
                  width = 12,
                  div(
                    style = "display: flex; justify-content: flex-end; margin-bottom: 10px;",
                    div(
                      style = "display: flex; align-items: center; gap: 10px;",
                      selectInput("residual_plot_type", "Plot Type:", 
                                  choices = c("Time Series", "Histogram", "QQ Plot", "ACF"),
                                  selected = "Time Series",
                                  width = "150px")
                    )
                  ),
                  
                  withSpinner(plotlyOutput("residual_plot", height = "300px"), type = 8, color = "#00a65a")
                )
              ),
              
              div(
                style = "margin-top: 15px;",
                fluidRow(
                  column(
                    width = 6,
                    h4("Residual Statistics"),
                    withSpinner(verbatimTextOutput("residual_stats"), type = 8, color = "#00a65a")
                  ),
                  column(
                    width = 6,
                    h4("Tests for Randomness"),
                    withSpinner(verbatimTextOutput("residual_tests"), type = 8, color = "#00a65a")
                  )
                )
              )
            ),
            
            # Advanced diagnostics tabbed view
            tabBox(
              id = "diagnostics_tabs",
              width = 12,
              
              tabPanel(
                "Model Parameters",
                div(
                  style = "margin-top: 15px;",
                  withSpinner(verbatimTextOutput("model_parameters"), type = 8, color = "#00a65a")
                ),
                hr(),
                h4("Parameter Stability"),
                withSpinner(plotlyOutput("parameter_stability", height = "250px"), type = 8, color = "#00a65a")
              ),
              
              tabPanel(
                "Seasonality Analysis",
                div(
                  style = "margin-top: 15px;",
                  withSpinner(plotlyOutput("seasonality_plot", height = "400px"), type = 8, color = "#00a65a")
                ),
                hr(),
                div(
                  style = "display: flex; flex-wrap: wrap; gap: 15px;",
                  div(
                    style = "flex: 1; min-width: 250px;",
                    h4("Seasonal Patterns"),
                    withSpinner(verbatimTextOutput("seasonal_patterns"), type = 8, color = "#00a65a")
                  ),
                  div(
                    style = "flex: 1; min-width: 250px;",
                    h4("Strength of Seasonality"),
                    withSpinner(verbatimTextOutput("seasonal_strength"), type = 8, color = "#00a65a")
                  )
                )
              ),
              
              tabPanel(
                "Forecast Evaluation",
                div(
                  style = "margin-top: 15px;",
                  h4("Forecast Error Analysis"),
                  withSpinner(plotlyOutput("forecast_error_plot", height = "250px"), type = 8, color = "#00a65a")
                ),
                hr(),
                div(
                  style = "display: flex; flex-wrap: wrap; gap: 15px;",
                  div(
                    style = "flex: 1; min-width: 250px;",
                    h4("Error Distribution"),
                    withSpinner(plotlyOutput("error_distribution", height = "200px"), type = 8, color = "#00a65a")
                  ),
                  div(
                    style = "flex: 1; min-width: 250px;",
                    h4("Error Statistics"),
                    withSpinner(verbatimTextOutput("error_stats"), type = 8, color = "#00a65a")
                  )
                )
              )
            )
          ),
          
          column(
            width = 4,
            
            # Model diagnostics summary
            box(
              width = 12,
              title = "Diagnostic Summary",
              status = "primary",
              solidHeader = TRUE,
              
              h4("Model Quality"),
              
              div(
                style = "margin-bottom: 15px;",
                div(
                  style = "display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px;",
                  span("Residual Randomness:"),
                  span(id = "residual_randomness_badge", class = "badge badge-success", "Good")
                ),
                div(class = "progress",
                    div(class = "progress-bar bg-success",
                        id = "residual_randomness_bar",
                        role = "progressbar",
                        style = "width: 80%",
                        "aria-valuenow" = "80",
                        "aria-valuemin" = "0",
                        "aria-valuemax" = "100"
                    )
                )
              ),
              
              div(
                style = "margin-bottom: 15px;",
                div(
                  style = "display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px;",
                  span("Parameter Significance:"),
                  span(id = "parameter_significance_badge", class = "badge badge-success", "Good")
                ),
                div(class = "progress",
                    div(class = "progress-bar bg-success", 
                        id = "parameter_significance_bar",
                        role = "progressbar",
                        style = "width: 75%",
                        "aria-valuenow" = "75",
                        "aria-valuemin" = "0",
                        "aria-valuemax" = "100"
                    )
                )
              ),
              
              div(
                style = "margin-bottom: 15px;",
                div(
                  style = "display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px;",
                  span("Forecast Accuracy:"),
                  span(id = "forecast_accuracy_badge", class = "badge badge-warning", "Moderate")
                ),
                div(class = "progress",
                    div(class = "progress-bar bg-warning", 
                        id = "forecast_accuracy_bar",
                        role = "progressbar",
                        style = "width: 60%",
                        "aria-valuenow" = "60",
                        "aria-valuemin" = "0",
                        "aria-valuemax" = "100"
                    )
                )
              ),
              
              div(
                style = "margin-bottom: 15px;",
                div(
                  style = "display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px;",
                  span("Overall Model Fit:"),
                  span(id = "overall_fit_badge", class = "badge badge-success", "Good")
                ),
                div(class = "progress",
                    div(class = "progress-bar bg-success", 
                        id = "overall_fit_bar",
                        role = "progressbar",
                        style = "width: 70%",
                        "aria-valuenow" = "70",
                        "aria-valuemin" = "0",
                        "aria-valuemax" = "100"
                    )
                )
              ),
              
              hr(),
              
              h4("Model Information"),
              withSpinner(verbatimTextOutput("diagnostics_info"), type = 8, color = "#00a65a")
            ),
            
            # Model comparison
            box(
              width = 12,
              title = "Model Comparison",
              status = "primary",
              solidHeader = TRUE,
              
              div(
                style = "display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;",
                div(
                  style = "flex: 1; min-width: 100px;",
                  checkboxInput("compare_arima", "ARIMA", TRUE)
                ),
                div(
                  style = "flex: 1; min-width: 100px;",
                  checkboxInput("compare_ets", "ETS", TRUE)
                ),
                div(
                  style = "flex: 1; min-width: 100px;",
                  checkboxInput("compare_prophet", "Prophet", FALSE)
                )
              ),
              
              div(
                style = "margin-bottom: 15px;",
                actionButton("run_comparison", "Run Comparison", 
                             icon = icon("chart-bar"), 
                             class = "btn-primary btn-block")
              ),
              
              withSpinner(plotlyOutput("comparison_plot", height = "200px"), type = 8, color = "#00a65a"),
              
              hr(),
              
              h4("Comparison Metrics"),
              withSpinner(DTOutput("comparison_table"), type = 8, color = "#00a65a")
            ),
            
            # Export diagnostics
            box(
              width = 12,
              title = "Export Diagnostics",
              status = "primary",
              solidHeader = TRUE,
              
              selectInput("export_diagnostics_format", "Export Format:",
                          choices = c(
                            "PDF Report" = "pdf",
                            "HTML Report" = "html",
                            "Word Document" = "docx"
                          ),
                          selected = "pdf"),
              
              div(
                style = "margin-top: 15px;",
                downloadButton("download_diagnostics", "Download Diagnostics Report", 
                               class = "btn-info btn-block")
              ),
              
              div(
                style = "margin-top: 15px;",
                div(
                  class = "alert alert-info",
                  icon("info-circle"),
                  "The report includes all diagnostic plots and statistics shown on this page."
                )
              )
            )
          )
        )
      ),
      
      # ===== Help Tab =====
      tabItem(
        tabName = "help",
        
        fluidRow(
          column(
            width = 12,
            
            # App overview
            box(
              width = 12,
              title = "TimeSeer: Advanced Time Series Forecasting",
              status = "primary",
              solidHeader = TRUE,
              
              div(
                style = "display: flex; flex-wrap: wrap; gap: 20px; align-items: center;",
                
                div(
                  style = "flex: 3; min-width: 300px;",
                  h3("About This Application"),
                  p("TimeSeer is a comprehensive time series forecasting tool designed to help you analyze historical data and generate accurate predictions. This application combines powerful statistical methods with an intuitive interface to make forecasting accessible to users of all experience levels."),
                  
                  h4("Key Features:"),
                  tags$ul(
                    tags$li(strong("Multiple Forecasting Methods:"), " ARIMA, Exponential Smoothing, and Prophet models"),
                    tags$li(strong("Data Preprocessing:"), " Handling missing values, outliers, and transformations"),
                    tags$li(strong("Interactive Visualizations:"), " Explore your data and forecasts with dynamic plots"),
                    tags$li(strong("Model Diagnostics:"), " Evaluate model performance and forecast accuracy"),
                    tags$li(strong("Export Capabilities:"), " Download results in various formats for further analysis")
                  )
                ),
                
                div(
                  style = "flex: 2; min-width: 200px; text-align: center;",
                  icon("chart-line", style = "font-size: 120px; color: #00a65a; opacity: 0.2;")
                )
              )
            )
          )
        ),
        
        fluidRow(
          # How to use
          column(
            width = 6,
            
            box(
              width = 12,
              title = "How to Use This Application",
              status = "primary",
              solidHeader = TRUE,
              
              div(
                style = "height: 500px; overflow-y: auto; padding: 0 10px;",
                
                h4("Step 1: Data Preparation and Upload"),
                p("Prepare your time series data in the required format:"),
                tags$ul(
                  tags$li(strong("Date:"), " Date column in yyyy-mm-dd format"),
                  tags$li(strong("Item_ID:"), " Unique identifier for each item/product"),
                  tags$li(strong("Item_Name:"), " Descriptive name for each item"),
                  tags$li(strong("Volume:"), " Numeric value to forecast (e.g., sales, demand)")
                ),
                p("Upload your data through the 'Data Input' section on the Data tab. Not sure about the format? Download our template for guidance."),
                
                hr(),
                
                h4("Step 2: Data Preprocessing"),
                p("Before forecasting, preprocess your data to ensure quality:"),
                tags$ul(
                  tags$li(strong("Missing Values:"), " Fill gaps using various methods (interpolation, mean fill, etc.)"),
                  tags$li(strong("Outliers:"), " Detect and handle unusual data points"),
                  tags$li(strong("Aggregation:"), " Adjust time granularity (e.g., daily to weekly)"),
                  tags$li(strong("Transformations:"), " Apply mathematical transformations to stabilize variance"),
                  tags$li(strong("Seasonality:"), " Analyze and adjust for seasonal patterns")
                ),
                p("Use the Preprocessing tab to access these features. Remember to click 'Apply Changes' to save your preprocessing steps."),
                
                hr(),
                
                h4("Step 3: Configure Forecast Settings"),
                p("Set up your forecast parameters:"),
                tags$ul(
                  tags$li(strong("Select Method:"), " Choose between ARIMA, Exponential Smoothing, or Prophet"),
                  tags$li(strong("Horizon:"), " Specify how far into the future to forecast"),
                  tags$li(strong("Frequency:"), " Set the time frequency of your data"),
                  tags$li(strong("Advanced Settings:"), " Configure method-specific parameters")
                ),
                p("Use the Forecast tab to configure these settings. You can generate a preview before running the full forecast."),
                
                hr(),
                
                h4("Step 4: Generate and Analyze Results"),
                p("Run the forecast and analyze the results:"),
                tags$ul(
                  tags$li("Click 'Run Forecast' to generate predictions"),
                  tags$li("View interactive plots showing historical data and forecasts"),
                  tags$li("Examine performance metrics (MAE, RMSE, MAPE)"),
                  tags$li("Export results for further analysis or reporting")
                ),
                p("Use the Results tab to explore your forecasts and their accuracy."),
                
                hr(),
                
                h4("Step 5: Diagnostic Evaluation"),
                p("Evaluate model quality and performance:"),
                tags$ul(
                  tags$li("Analyze residuals to check model assumptions"),
                  tags$li("Examine parameter stability and significance"),
                  tags$li("Compare different forecasting methods"),
                  tags$li("Generate diagnostic reports")
                ),
                p("Use the Diagnostics tab to access these advanced evaluation features.")
              )
            )
          ),
          
          column(
            width = 6,
            
            # FAQ section
            box(
              width = 12,
              title = "Frequently Asked Questions",
              status = "primary",
              solidHeader = TRUE,
              
              div(
                style = "height: 250px; overflow-y: auto; padding: 0 10px;",
                
                div(
                  class = "panel-group",
                  id = "faq_accordion",
                  
                  # FAQ Item 1
                  div(
                    class = "panel panel-default",
                    div(
                      class = "panel-heading",
                      style = "background-color: #f5f5f5; padding: 10px; border-radius: 3px; margin-bottom: 5px;",
                      h4(
                        class = "panel-title",
                        tags$a(
                          "data-toggle" = "collapse",
                          "data-parent" = "#faq_accordion",
                          href = "#faq1",
                          "What data format is required?",
                          style = "text-decoration: none; display: block;"
                        )
                      )
                    ),
                    div(
                      id = "faq1",
                      class = "panel-collapse collapse",
                      div(
                        class = "panel-body",
                        p("Your data should be in CSV or Excel format with columns for Date, Item_ID, Item_Name, and Volume. The Date should be in a standard format (e.g., YYYY-MM-DD), and Volume should contain numeric values to forecast. You can download a template from the Data tab for reference.")
                      )
                    )
                  ),
                  
                  # FAQ Item 2
                  div(
                    class = "panel panel-default",
                    div(
                      class = "panel-heading",
                      style = "background-color: #f5f5f5; padding: 10px; border-radius: 3px; margin-bottom: 5px;",
                      h4(
                        class = "panel-title",
                        tags$a(
                          "data-toggle" = "collapse",
                          "data-parent" = "#faq_accordion",
                          href = "#faq2",
                          "Which forecasting method should I use?",
                          style = "text-decoration: none; display: block;"
                        )
                      )
                    ),
                    div(
                      id = "faq2",
                      class = "panel-collapse collapse",
                      div(
                        class = "panel-body",
                        tags$ul(
                          tags$li(strong("ARIMA:"), " Best for data with clear trends and/or seasonality. Works well with stationary data or after applying differencing."),
                          tags$li(strong("Exponential Smoothing:"), " Good for data with trend and seasonality, especially when you want to give more weight to recent observations."),
                          tags$li(strong("Prophet:"), " Excellent for business time series with multiple seasonal patterns, holidays, and missing data.")
                        ),
                        p("When in doubt, you can run all methods and compare their performance in the Diagnostics tab.")
                      )
                    )
                  ),
                  
                  # FAQ Item 3
                  div(
                    class = "panel panel-default",
                    div(
                      class = "panel-heading",
                      style = "background-color: #f5f5f5; padding: 10px; border-radius: 3px; margin-bottom: 5px;",
                      h4(
                        class = "panel-title",
                        tags$a(
                          "data-toggle" = "collapse",
                          "data-parent" = "#faq_accordion",
                          href = "#faq3",
                          "How do I interpret the performance metrics?",
                          style = "text-decoration: none; display: block;"
                        )
                      )
                    ),
                    div(
                      id = "faq3",
                      class = "panel-collapse collapse",
                      div(
                        class = "panel-body",
                        tags$ul(
                          tags$li(strong("MAE (Mean Absolute Error):"), " Average absolute difference between forecasted and actual values. Lower is better."),
                          tags$li(strong("RMSE (Root Mean Square Error):"), " Root of the average squared differences between forecasted and actual values. More sensitive to large errors than MAE. Lower is better."),
                          tags$li(strong("MAPE (Mean Absolute Percentage Error):"), " Average of absolute percentage differences between forecasted and actual values. Expressed as a percentage, lower is better.")
                        ),
                        p("Generally, you want to select the model with the lowest values across these metrics.")
                      )
                    )
                  ),
                  
                  # FAQ Item 4
                  div(
                    class = "panel panel-default",
                    div(
                      class = "panel-heading",
                      style = "background-color: #f5f5f5; padding: 10px; border-radius: 3px; margin-bottom: 5px;",
                      h4(
                        class = "panel-title",
                        tags$a(
                          "data-toggle" = "collapse",
                          "data-parent" = "#faq_accordion",
                          href = "#faq4",
                          "How do I handle outliers in my data?",
                          style = "text-decoration: none; display: block;"
                        )
                      )
                    ),
                    div(
                      id = "faq4",
                      class = "panel-collapse collapse",
                      div(
                        class = "panel-body",
                        p("Outliers can significantly impact forecast accuracy. In the Preprocessing tab, you can:"),
                        tags$ol(
                          tags$li("Select an outlier detection method (IQR, Z-score, or GESD)"),
                          tags$li("Set the threshold for detection sensitivity"),
                          tags$li("Choose how to handle outliers (keep, remove, replace with mean/median, or winsorize)")
                        ),
                        p("The best approach depends on your data. If outliers represent genuine events (like promotions or holidays), you might want to keep them or incorporate them as external factors.")
                      )
                    )
                  ),
                  
                  # FAQ Item 5
                  div(
                    class = "panel panel-default",
                    div(
                      class = "panel-heading",
                      style = "background-color: #f5f5f5; padding: 10px; border-radius: 3px; margin-bottom: 5px;",
                      h4(
                        class = "panel-title",
                        tags$a(
                          "data-toggle" = "collapse",
                          "data-parent" = "#faq_accordion",
                          href = "#faq5",
                          "What does cross-validation do?",
                          style = "text-decoration: none; display: block;"
                        )
                      )
                    ),
                    div(
                      id = "faq5",
                      class = "panel-collapse collapse",
                      div(
                        class = "panel-body",
                        p("Cross-validation helps assess how well your model will perform on unseen data. The app offers two methods:"),
                        tags$ul(
                          tags$li(strong("Rolling Window:"), " Creates multiple training sets of fixed size that 'roll' through the time series"),
                          tags$li(strong("Expanding Window:"), " Creates training sets that grow larger with each fold, keeping all historical data")
                        ),
                        p("Cross-validation gives you a more reliable estimate of model performance than a single train-test split, especially for time series data where dependencies exist between observations.")
                      )
                    )
                  )
                )
              )
            ),
            
            # Methods explanation
            box(
              width = 12,
              title = "Forecasting Methods Explained",
              status = "primary",
              solidHeader = TRUE,
              
              div(
                style = "height: 250px; overflow-y: auto; padding: 0 10px;",
                
                # ARIMA
                h4("ARIMA (Auto-Regressive Integrated Moving Average)"),
                div(
                  style = "display: flex; flex-wrap: wrap; gap: 20px;",
                  div(
                    style = "flex: 3; min-width: 200px;",
                    p("ARIMA models combine three components:"),
                    tags$ul(
                      tags$li(strong("AR (Auto-Regressive):"), " Uses the dependent relationship between current observation and previous observations"),
                      tags$li(strong("I (Integrated):"), " Uses differencing to make the time series stationary"),
                      tags$li(strong("MA (Moving Average):"), " Uses the dependency between observation and residual error from a moving average model")
                    ),
                    p("ARIMA is specified as ARIMA(p,d,q) where:"),
                    tags$ul(
                      tags$li("p = Order of the AR term"),
                      tags$li("d = Order of the differencing"),
                      tags$li("q = Order of the MA term")
                    ),
                    p("Seasonal ARIMA extends this with seasonal components: ARIMA(p,d,q)(P,D,Q)m, where m is the seasonal period.")
                  ),
                  div(
                    style = "flex: 2; min-width: 150px; text-align: center;",
                    img(src = "https://www.statsmodels.org/stable/_images/arima_plot.png", style = "max-width: 100%; height: auto;")
                  )
                ),
                
                hr(),
                
                # Exponential Smoothing
                h4("Exponential Smoothing (ETS)"),
                div(
                  style = "display: flex; flex-wrap: wrap; gap: 20px;",
                  div(
                    style = "flex: 3; min-width: 200px;",
                    p("Exponential smoothing methods assign exponentially decreasing weights to past observations. ETS models have components for:"),
                    tags$ul(
                      tags$li(strong("Error (E):"), " Additive (A) or Multiplicative (M)"),
                      tags$li(strong("Trend (T):"), " None (N), Additive (A), or Multiplicative (M)"),
                      tags$li(strong("Seasonality (S):"), " None (N), Additive (A), or Multiplicative (M)")
                    ),
                    p("Models are specified as ETS(Error,Trend,Seasonality), for example:"),
                    tags$ul(
                      tags$li(strong("ETS(A,N,N):"), " Simple exponential smoothing with additive errors"),
                      tags$li(strong("ETS(A,A,N):"), " Holt's linear method with additive errors"),
                      tags$li(strong("ETS(A,A,A):"), " Additive Holt-Winters method")
                    )
                  ),
                  div(
                    style = "flex: 2; min-width: 150px; text-align: center;",
                    img(src = "https://otexts.com/fpp2/figs/7-decomp.png", style = "max-width: 100%; height: auto;")
                  )
                ),
                
                hr(),
                
                # Prophet
                h4("Prophet"),
                div(
                  style = "display: flex; flex-wrap: wrap; gap: 20px;",
                  div(
                    style = "flex: 3; min-width: 200px;",
                    p("Prophet is a procedure for forecasting time series data developed by Facebook. It's based on an additive model where non-linear trends are fit with yearly, weekly, and daily seasonality, plus holiday effects."),
                    p("Key features include:"),
                    tags$ul(
                      tags$li("Handles missing data and outliers well"),
                      tags$li("Automatically detects changes in trends"),
                      tags$li("Accommodates multiple seasonal patterns"),
                      tags$li("Incorporates holiday effects"),
                      tags$li("Typically requires minimal parameter tuning")
                    ),
                    p("Prophet is particularly suited for business forecasting tasks with strong seasonal effects and several seasons of historical data.")
                  ),
                  div(
                    style = "flex: 2; min-width: 150px; text-align: center;",
                    img(src = "https://facebook.github.io/prophet/static/trend_changepoints-89a63c0c00e01e9fec8d18d2b99a265a.png", style = "max-width: 100%; height: auto;")
                  )
                )
              )
            )
          )
        ),
        
        # Terminology and glossary
        fluidRow(
          column(
            width = 12,
            
            box(
              width = 12,
              title = "Time Series Forecasting Glossary",
              status = "primary",
              solidHeader = TRUE,
              
              div(
                style = "height: 300px; overflow-y: auto; padding: 0 10px;",
                
                div(
                  style = "column-count: 2; column-gap: 30px;",
                  
                  div(
                    tags$dl(
                      tags$dt("Autocorrelation"),
                      tags$dd("Correlation between observations of a time series separated by k time units."),
                      
                      tags$dt("Baseline Forecast"),
                      tags$dd("Simple forecast method (like nave or seasonal nave) used as a benchmark."),
                      
                      tags$dt("Changepoint"),
                      tags$dd("Point in time where the underlying trend of a time series changes."),
                      
                      tags$dt("Cross-Validation"),
                      tags$dd("Technique to evaluate model performance by testing it on multiple subsets of data."),
                      
                      tags$dt("Decomposition"),
                      tags$dd("Breaking a time series into components: trend, seasonality, and residual."),
                      
                      tags$dt("Differencing"),
                      tags$dd("Taking the difference between consecutive observations to make a series stationary."),
                      
                      tags$dt("Forecast Horizon"),
                      tags$dd("Number of time periods into the future for which forecasts are generated."),
                      
                      tags$dt("Heteroscedasticity"),
                      tags$dd("When the variability of a time series is not constant over time.")
                    )
                  ),
                  
                  div(
                    tags$dl(
                      tags$dt("MAE (Mean Absolute Error)"),
                      tags$dd("Average of absolute errors between forecasted and actual values."),
                      
                      tags$dt("MAPE (Mean Absolute Percentage Error)"),
                      tags$dd("Average of absolute percentage errors between forecasted and actual values."),
                      
                      tags$dt("Residuals"),
                      tags$dd("Differences between observed values and values predicted by a model."),
                      
                      tags$dt("RMSE (Root Mean Square Error)"),
                      tags$dd("Square root of the average of squared differences between forecasted and actual values."),
                      
                      tags$dt("Seasonality"),
                      tags$dd("Regular pattern that repeats over a fixed period (daily, weekly, monthly, etc.)."),
                      
                      tags$dt("Stationarity"),
                      tags$dd("Property where statistical properties like mean and variance don't change over time."),
                      
                      tags$dt("Time Series"),
                      tags$dd("Sequence of data points in time order, typically with equal intervals between observations."),
                      
                      tags$dt("Trend"),
                      tags$dd("Long-term increase or decrease in the data.")
                    )
                  )
                )
              )
            )
          )
        ),
        
        # Resources section
        fluidRow(
          column(
            width = 12,
            
            box(
              width = 12,
              title = "Additional Resources",
              status = "primary",
              solidHeader = TRUE,
              
              div(
                style = "display: flex; flex-wrap: wrap; gap: 30px;",
                
                div(
                  style = "flex: 1; min-width: 250px;",
                  h4("Books & Publications"),
                  tags$ul(
                    tags$li(tags$a(href = "https://otexts.com/fpp3/", "Forecasting: Principles and Practice (3rd ed.) by Rob J. Hyndman and George Athanasopoulos", target = "_blank")),
                    tags$li(tags$a(href = "https://www.wiley.com/en-us/Time+Series+Analysis%3A+Forecasting+and+Control%2C+5th+Edition-p-9781118675021", "Time Series Analysis: Forecasting and Control by Box, Jenkins, Reinsel & Ljung", target = "_blank")),
                    tags$li(tags$a(href = "https://www.oreilly.com/library/view/practical-time-series/9781492041641/", "Practical Time Series Analysis by Aileen Nielsen", target = "_blank"))
                  )
                ),
                
                div(
                  style = "flex: 1; min-width: 250px;",
                  h4("Online Resources"),
                  tags$ul(
                    tags$li(tags$a(href = "https://facebook.github.io/prophet/", "Prophet Documentation", target = "_blank")),
                    tags$li(tags$a(href = "https://online.stat.psu.edu/stat510/", "Applied Time Series Analysis (Penn State)", target = "_blank")),
                    tags$li(tags$a(href = "https://robjhyndman.com/hyndsight/", "Rob J. Hyndman's Blog on Forecasting", target = "_blank")),
                    tags$li(tags$a(href = "https://www.rdocumentation.org/packages/forecast/versions/8.15", "forecast R Package Documentation", target = "_blank"))
                  )
                ),
                
                div(
                  style = "flex: 1; min-width: 250px;",
                  h4("R Packages Used"),
                  tags$ul(
                    tags$li(tags$a(href = "https://pkg.robjhyndman.com/forecast/", "forecast", target = "_blank"), " - Forecasting functions for time series"),
                    tags$li(tags$a(href = "https://cran.r-project.org/web/packages/prophet/", "prophet", target = "_blank"), " - Facebook's time series forecasting procedure"),
                    tags$li(tags$a(href = "https://cran.r-project.org/web/packages/tseries/", "tseries", target = "_blank"), " - Time series analysis and computational finance"),
                    tags$li(tags$a(href = "https://cran.r-project.org/web/packages/zoo/", "zoo", target = "_blank"), " - Z's ordered observations (irregular time series)")
                  )
                )
              ),
              
              hr(),
              
              div(
                style = "text-align: center;",
                p("For support or to report issues, please contact:", style = "margin-bottom: 5px;"),
                p(tags$a(href = "mailto:support@timeseer.com", "support@timeseer.com"), style = "font-weight: bold;"),
                p("TimeSeer  2023. All rights reserved.", style = "color: #999; font-size: 12px; margin-top: 15px;")
              )
            )
          )
        )
      )
    )
  )
)

# To test the UI, use:
# 

# ==========================================
# TimeSeer: Server Functions
# ==========================================

# Required libraries for the server
library(shiny)
library(shinydashboard)
library(DT)
library(plotly)
library(dplyr)
library(tidyr)
library(lubridate)
library(forecast)
library(tseries)
library(zoo)
library(readxl)
library(writexl)
library(ggplot2)

# Server function
server <- function(input, output, session) {
  
  # Reactive values for storing data and results
  rv <- reactiveValues(
    data = NULL,                # Original uploaded data
    processed_data = NULL,      # Data after preprocessing
    outliers = NULL,            # Detected outliers
    forecast_results = NULL,    # Forecast results
    model_objects = list(),     # Store model objects
    performance_metrics = list(), # Performance metrics
    error_message = NULL,       # Error messages
    preprocessing_steps = list(), # Track preprocessing steps applied
    current_item = NULL,        # Currently selected item
    data_loaded = FALSE,        # Flag for data loading status
    forecast_generated = FALSE  # Flag for forecast status
  )
  
  # ===== Template Download Handler =====
  output$download_Tem <- downloadHandler(
    filename = function() {
      "forecast_template.xlsx"
    },
    content = function(file) {
      # Create template data
      date_seq <- data.frame(
        Date = seq.Date(
          from = Sys.Date() - days(30),
          to = Sys.Date(),
          by = 'day'
        )
      )
      
      item_seq <- data.frame(Item_ID = c(1001, 1002, 1003))
      template_data <- crossing(date_seq, item_seq)
      
      # Add item names and sample volumes
      template_data <- template_data %>%
        mutate(
          Item_Name = case_when(
            Item_ID == 1001 ~ "Product A",
            Item_ID == 1002 ~ "Product B",
            Item_ID == 1003 ~ "Product C",
            TRUE ~ paste0("Item ", Item_ID)
          ),
          Volume = round(case_when(
            Item_ID == 1001 ~ runif(n(), 800, 1200) + 100 * sin(as.numeric(Date - min(Date)) / 7),
            Item_ID == 1002 ~ runif(n(), 400, 600) + 50 * cos(as.numeric(Date - min(Date)) / 7),
            Item_ID == 1003 ~ runif(n(), 1000, 1500) + 200 * sin(as.numeric(Date - min(Date)) / 14),
            TRUE ~ runif(n(), 500, 1000)
          ))
        )
      
      # Write to Excel
      write_xlsx(template_data, file)
    }
  )
  
  # ===== File Upload Handler =====
  observeEvent(input$file, {
    req(input$file)
    
    withProgress(message = 'Loading data...', value = 0, {
      tryCatch({
        # Determine file type and read data
        file_ext <- tools::file_ext(input$file$datapath)
        
        if (file_ext == "csv") {
          data <- read.csv(input$file$datapath, header = input$header)
        } else if (file_ext %in% c("xlsx", "xls")) {
          data <- read_excel(input$file$datapath)
        } else {
          stop("Unsupported file format. Please upload a CSV or Excel file.")
        }
        
        # Basic data validation
        required_cols <- c("Date", "Item_ID", "Item_Name", "Volume")
        if (!all(required_cols %in% colnames(data))) {
          # Try to match column names case-insensitively
          col_mapping <- setNames(
            colnames(data),
            tolower(colnames(data))
          )
          
          mapped_cols <- sapply(tolower(required_cols), function(col) {
            if (col %in% names(col_mapping)) return(col_mapping[col])
            return(NA)
          })
          
          if (any(is.na(mapped_cols))) {
            missing_cols <- required_cols[tolower(required_cols) %in% names(col_mapping)[is.na(mapped_cols)]]
            stop(paste("Missing required columns:", paste(missing_cols, collapse = ", ")))
          }
          
          # Rename columns to standard format
          data <- data %>% 
            select(all_of(mapped_cols)) %>%
            rename_with(~ required_cols, all_of(mapped_cols))
        }
        
        # Data type conversion
        data <- data %>%
          mutate(
            Date = as.Date(Date),
            Item_ID = as.character(Item_ID),
            Item_Name = as.character(Item_Name),
            Volume = as.numeric(Volume)
          )
        
        # Validate data after conversion
        if (any(is.na(data$Date))) {
          stop("Invalid date format in Date column")
        }
        
        if (any(is.na(data$Volume)) && !input$allow_missing) {
          warning("Missing values detected in Volume column")
        }
        
        # Store data in reactive values
        rv$data <- data
        rv$processed_data <- data  # Initialize processed data with original
        rv$data_loaded <- TRUE
        
        # Update item selection dropdowns
        updateSelectInput(session, "selectitem",
                          choices = unique(data$Item_Name),
                          selected = unique(data$Item_Name)[1])
        
        updateSelectInput(session, "forecast_item",
                          choices = unique(data$Item_Name),
                          selected = unique(data$Item_Name)[1])
        
        updateSelectInput(session, "results_item",
                          choices = unique(data$Item_Name),
                          selected = unique(data$Item_Name)[1])
        
        updateSelectInput(session, "diagnostics_item",
                          choices = unique(data$Item_Name),
                          selected = unique(data$Item_Name)[1])
        
        # Set current item
        rv$current_item <- unique(data$Item_Name)[1]
        
        # Notify user
        showNotification("Data loaded successfully", type = "message")
        
      }, error = function(e) {
        # Handle errors
        rv$error_message <- paste("Error loading file:", e$message)
        showNotification(rv$error_message, type = "error", duration = 10)
      }, warning = function(w) {
        # Handle warnings
        showNotification(paste("Warning:", w$message), type = "warning", duration = 7)
      })
    })
  })
  
  # ===== Data Preview =====
  output$data_preview <- renderDT({
    req(rv$data)
    
    # Format date for display
    display_data <- rv$data %>%
      mutate(Date = format(Date, "%Y-%m-%d"))
    
    datatable(
      display_data,
      options = list(
        pageLength = 10,
        scrollX = TRUE,
        autoWidth = TRUE
      ),
      rownames = FALSE,
      filter = 'top',
      class = 'cell-border stripe'
    )
  })
  
  # ===== Data Summary =====
  output$data_summary <- renderPrint({
    req(rv$data)
    
    # Generate summary statistics
    cat("Dataset Summary:\n\n")
    
    # Overall summary
    cat("Number of observations:", nrow(rv$data), "\n")
    cat("Date range:", format(min(rv$data$Date), "%Y-%m-%d"), "to", 
        format(max(rv$data$Date), "%Y-%m-%d"), "\n")
    cat("Number of unique items:", length(unique(rv$data$Item_ID)), "\n\n")
    
    # Volume summary
    cat("Volume Statistics:\n")
    volume_summary <- summary(rv$data$Volume)
    print(volume_summary)
    
    # Missing values
    missing_count <- sum(is.na(rv$data$Volume))
    if (missing_count > 0) {
      cat("\nMissing values in Volume:", missing_count, 
          "(", round(missing_count/nrow(rv$data)*100, 2), "%)\n")
    } else {
      cat("\nNo missing values in Volume\n")
    }
    
    # Item frequency
    cat("\nObservations per Item:\n")
    item_counts <- rv$data %>%
      group_by(Item_Name) %>%
      summarise(Count = n(), .groups = 'drop') %>%
      arrange(desc(Count))
    print(as.data.frame(item_counts))
  })
  
  # ===== Data Structure =====
  output$data_structure <- renderPrint({
    req(rv$data)
    
    cat("Data Structure:\n\n")
    str(rv$data)
    
    cat("\n\nColumn Classes:\n")
    sapply(rv$data, class)
  })
  
  # ===== Missing Values Plot =====
  output$missing_values_plot <- renderPlot({
    req(rv$data)
    
    # Prepare data for visualization
    missing_data <- rv$data %>%
      group_by(Date) %>%
      summarise(
        Total = n(),
        Missing = sum(is.na(Volume)),
        Pct_Missing = Missing / Total * 100,
        .groups = 'drop'
      )
    
    # Create plot
    ggplot(missing_data, aes(x = Date)) +
      geom_line(aes(y = Pct_Missing), color = "red", size = 1) +
      geom_point(aes(y = Pct_Missing), color = "red", size = 3) +
      labs(
        title = "Missing Values Over Time",
        x = "Date",
        y = "Percentage of Missing Values (%)"
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        axis.title = element_text(face = "bold"),
        panel.grid.major = element_line(color = "grey90"),
        panel.grid.minor = element_line(color = "grey95")
      )
  })
  
  # ===== Status Boxes =====
  output$data_status_box <- renderValueBox({
    if (rv$data_loaded) {
      valueBox(
        "Data Loaded",
        paste(nrow(rv$data), "records"),
        icon = icon("check-circle"),
        color = "green"
      )
    } else {
      valueBox(
        "No Data",
        "Upload data to begin",
        icon = icon("upload"),
        color = "yellow"
      )
    }
  })
  
  output$items_count_box <- renderValueBox({
    req(rv$data)
    
    valueBox(
      length(unique(rv$data$Item_ID)),
      "Unique Items",
      icon = icon("box"),
      color = "blue"
    )
  })
  
  output$date_range_box <- renderValueBox({
    req(rv$data)
    
    date_diff <- as.numeric(max(rv$data$Date) - min(rv$data$Date))
    
    valueBox(
      paste(date_diff, "days"),
      paste("From", format(min(rv$data$Date), "%Y-%m-%d"), "to", format(max(rv$data$Date), "%Y-%m-%d")),
      icon = icon("calendar"),
      color = "purple"
    )
  })
  
  output$forecast_status_box <- renderValueBox({
    if (rv$forecast_generated) {
      valueBox(
        "Forecast Ready",
        paste("Generated for", length(unique(rv$forecast_results$Item_ID)), "items"),
        icon = icon("chart-line"),
        color = "green"
      )
    } else {
      valueBox(
        "No Forecast",
        "Configure and run forecasting",
        icon = icon("play-circle"),
        color = "red"
      )
    }
  })
  
  # Sync item selection across tabs
  observeEvent(input$selectitem, {
    req(input$selectitem)
    rv$current_item <- input$selectitem
    updateSelectInput(session, "forecast_item", selected = input$selectitem)
    updateSelectInput(session, "results_item", selected = input$selectitem)
    updateSelectInput(session, "diagnostics_item", selected = input$selectitem)
  })
  
  observeEvent(input$forecast_item, {
    req(input$forecast_item)
    rv$current_item <- input$forecast_item
    updateSelectInput(session, "selectitem", selected = input$forecast_item)
    updateSelectInput(session, "results_item", selected = input$forecast_item)
    updateSelectInput(session, "diagnostics_item", selected = input$forecast_item)
  })
  
  observeEvent(input$results_item, {
    req(input$results_item)
    rv$current_item <- input$results_item
    updateSelectInput(session, "selectitem", selected = input$results_item)
    updateSelectInput(session, "forecast_item", selected = input$results_item)
    updateSelectInput(session, "diagnostics_item", selected = input$results_item)
  })
  
  observeEvent(input$diagnostics_item, {
    req(input$diagnostics_item)
    rv$current_item <- input$diagnostics_item
    updateSelectInput(session, "selectitem", selected = input$diagnostics_item)
    updateSelectInput(session, "forecast_item", selected = input$diagnostics_item)
    updateSelectInput(session, "results_item", selected = input$diagnostics_item)
  })
  
  
  
  
  # ===== Preprocessing Plot =====
  output$preprocessing_plot <- renderPlotly({
    req(rv$processed_data, rv$current_item)
    
    # Filter data for selected item
    if (input$show_all_items) {
      plot_data <- rv$processed_data
      title_text <- "All Items"
      
      # Create a palette with a unique color for each item
      num_items <- length(unique(plot_data$Item_Name))
      colors <- colorRampPalette(c("#00a65a", "#3c8dbc", "#f39c12", "#dd4b39"))(num_items)
      
      p <- plot_ly() %>%
        layout(
          title = list(text = paste("Time Series Visualization:", title_text)),
          xaxis = list(title = "Date"),
          yaxis = list(title = "Volume"),
          hovermode = "closest",
          legend = list(orientation = "h", y = -0.2)
        )
      
      # Add a trace for each item
      for (i in seq_along(unique(plot_data$Item_Name))) {
        item <- unique(plot_data$Item_Name)[i]
        item_data <- plot_data %>% filter(Item_Name == item)
        
        if (input$plot_type == "Line") {
          p <- p %>% add_trace(
            data = item_data,
            x = ~Date,
            y = ~Volume,
            type = 'scatter',
            mode = 'lines',
            name = item,
            line = list(color = colors[i], width = 2)
          )
        } else if (input$plot_type == "Bar") {
          p <- p %>% add_trace(
            data = item_data,
            x = ~Date,
            y = ~Volume,
            type = 'bar',
            name = item,
            marker = list(color = colors[i])
          )
        } else if (input$plot_type == "Point") {
          p <- p %>% add_trace(
            data = item_data,
            x = ~Date,
            y = ~Volume,
            type = 'scatter',
            mode = 'markers',
            name = item,
            marker = list(color = colors[i], size = 6)
          )
        } else if (input$plot_type == "Area") {
          p <- p %>% add_trace(
            data = item_data,
            x = ~Date,
            y = ~Volume,
            type = 'scatter',
            mode = 'lines',
            fill = 'tozeroy',
            name = item,
            fillcolor = paste0(colors[i], "60"),  # Add transparency
            line = list(color = colors[i], width = 2)
          )
        }
      }
      
    } else {
      # Filter for specific item
      plot_data <- rv$processed_data %>%
        filter(Item_Name == rv$current_item)
      
      title_text <- rv$current_item
      
      if (input$plot_type == "Line") {
        p <- plot_ly(
          data = plot_data,
          x = ~Date,
          y = ~Volume,
          type = 'scatter',
          mode = 'lines',
          line = list(color = '#00a65a', width = 2),
          name = 'Volume'
        )
      } else if (input$plot_type == "Bar") {
        p <- plot_ly(
          data = plot_data,
          x = ~Date,
          y = ~Volume,
          type = 'bar',
          marker = list(color = '#00a65a'),
          name = 'Volume'
        )
      } else if (input$plot_type == "Point") {
        p <- plot_ly(
          data = plot_data,
          x = ~Date,
          y = ~Volume,
          type = 'scatter',
          mode = 'markers',
          marker = list(color = '#00a65a', size = 6),
          name = 'Volume'
        )
      } else if (input$plot_type == "Area") {
        p <- plot_ly(
          data = plot_data,
          x = ~Date,
          y = ~Volume,
          type = 'scatter',
          mode = 'lines',
          fill = 'tozeroy',
          fillcolor = 'rgba(0, 166, 90, 0.4)',
          line = list(color = '#00a65a', width = 2),
          name = 'Volume'
        )
      }
      
      # Add outliers if requested
      if (input$show_outliers && !is.null(rv$outliers)) {
        outlier_data <- rv$outliers %>%
          filter(Item_Name == rv$current_item)
        
        if (nrow(outlier_data) > 0) {
          p <- p %>% add_trace(
            data = outlier_data,
            x = ~Date,
            y = ~Volume,
            type = 'scatter',
            mode = 'markers',
            marker = list(color = '#dd4b39', size = 8, symbol = 'circle'),
            name = 'Outliers'
          )
        }
      }
      
      p <- p %>% layout(
        title = list(text = paste("Time Series Visualization:", title_text)),
        xaxis = list(title = "Date"),
        yaxis = list(title = "Volume"),
        hovermode = "closest"
      )
    }
    
    return(p)
  })
  
  # ===== Detect Outliers Function =====
  detect_outliers <- function(data, method = "iqr", threshold = 3) {
    if (nrow(data) < 3) {
      return(data %>% mutate(is_outlier = FALSE, outlier_severity = "Normal"))
    }
    
    result <- data %>%
      group_by(Item_ID) %>%
      mutate(
        is_outlier = FALSE,
        outlier_severity = "Normal"
      )
    
    if (method == "iqr") {
      result <- result %>%
        mutate(
          Q1 = quantile(Volume, 0.25, na.rm = TRUE),
          Q3 = quantile(Volume, 0.75, na.rm = TRUE),
          IQR = Q3 - Q1,
          lower_bound = Q1 - threshold * IQR,
          upper_bound = Q3 + threshold * IQR,
          is_outlier = Volume < lower_bound | Volume > upper_bound,
          outlier_severity = case_when(
            Volume < lower_bound ~ "Low",
            Volume > upper_bound ~ "High",
            TRUE ~ "Normal"
          )
        )
    } else if (method == "zscore") {
      result <- result %>%
        mutate(
          z_score = abs((Volume - mean(Volume, na.rm = TRUE)) / sd(Volume, na.rm = TRUE)),
          is_outlier = z_score > threshold,
          outlier_severity = case_when(
            is_outlier & Volume > mean(Volume, na.rm = TRUE) ~ "High",
            is_outlier & Volume <= mean(Volume, na.rm = TRUE) ~ "Low",
            TRUE ~ "Normal"
          )
        )
    } else if (method == "gesd") {
      # Generalized ESD test for each group
      # This is a simplified version, the actual GESD is more complex
      result <- result %>%
        mutate(
          median_val = median(Volume, na.rm = TRUE),
          mad_val = mad(Volume, na.rm = TRUE),
          is_outlier = abs(Volume - median_val) > threshold * mad_val,
          outlier_severity = case_when(
            is_outlier & Volume > median_val ~ "High",
            is_outlier & Volume <= median_val ~ "Low",
            TRUE ~ "Normal"
          )
        )
    }
    
    return(result %>% 
             select(-matches("^Q[1-3]$|^IQR$|^lower_bound$|^upper_bound$|^z_score$|^median_val$|^mad_val$")) %>%
             ungroup())
  }
  
  # ===== Handle Missing Values =====
  observeEvent(input$apply_missing, {
    req(rv$processed_data)
    
    withProgress(message = 'Processing missing values...', value = 0, {
      
      tryCatch({
        # Apply missing value treatment to current data
        processed_data <- rv$processed_data %>%
          group_by(Item_ID) %>%
          arrange(Date) %>%
          mutate(Volume = case_when(
            input$missing_treatment == "linear" ~ {
              if (sum(is.na(Volume)) == 0) Volume 
              else as.numeric(zoo::na.approx(Volume, na.rm = FALSE))
            },
            input$missing_treatment == "ffill" ~ {
              if (sum(is.na(Volume)) == 0) Volume 
              else as.numeric(zoo::na.locf(Volume, na.rm = FALSE))
            },
            input$missing_treatment == "bfill" ~ {
              if (sum(is.na(Volume)) == 0) Volume 
              else as.numeric(zoo::na.locf(Volume, fromLast = TRUE, na.rm = FALSE))
            },
            input$missing_treatment == "mean" ~ {
              if (sum(is.na(Volume)) == 0) Volume 
              else ifelse(is.na(Volume), mean(Volume, na.rm = TRUE), Volume)
            },
            input$missing_treatment == "median" ~ {
              if (sum(is.na(Volume)) == 0) Volume 
              else ifelse(is.na(Volume), median(Volume, na.rm = TRUE), Volume)
            },
            TRUE ~ Volume
          )) %>%
          ungroup()
        
        # If remove option selected, filter out rows with NA
        if (input$missing_treatment == "remove") {
          processed_data <- processed_data %>%
            filter(!is.na(Volume))
        }
        
        # Store the processing step
        rv$preprocessing_steps$missing_values <- list(
          method = input$missing_treatment,
          timestamp = Sys.time()
        )
        
        # Update processed data
        rv$processed_data <- processed_data
        
        # Notify user
        showNotification(
          paste("Missing values handled using", input$missing_treatment, "method"), 
          type = "message"
        )
        
      }, error = function(e) {
        showNotification(
          paste("Error handling missing values:", e$message), 
          type = "error"
        )
      })
    })
  })
  
  # ===== Handle Duplicates =====
  observeEvent(input$apply_duplicates, {
    req(rv$processed_data)
    
    withProgress(message = 'Processing duplicates...', value = 0, {
      
      tryCatch({
        # Check if there are any duplicates
        has_duplicates <- rv$processed_data %>%
          group_by(Date, Item_ID) %>%
          summarise(count = n(), .groups = "drop") %>%
          filter(count > 1) %>%
          nrow() > 0
        
        if (!has_duplicates) {
          showNotification("No duplicates found in the data", type = "message")
          return()
        }
        
        # Apply duplicate handling
        processed_data <- rv$processed_data %>%
          group_by(Date, Item_ID, Item_Name) %>%
          summarise(
            Volume = case_when(
              input$duplicate_handling == "first" ~ first(Volume),
              input$duplicate_handling == "last" ~ last(Volume),
              input$duplicate_handling == "sum" ~ sum(Volume, na.rm = TRUE),
              input$duplicate_handling == "mean" ~ mean(Volume, na.rm = TRUE),
              input$duplicate_handling == "keep" ~ first(Volume), # Keep all actually needs special handling
              TRUE ~ first(Volume)
            ),
            .groups = "drop"
          )
        
        # If "keep" option selected, don't actually summarize
        if (input$duplicate_handling == "keep") {
          processed_data <- rv$processed_data
        }
        
        # Store the processing step
        rv$preprocessing_steps$duplicates <- list(
          method = input$duplicate_handling,
          timestamp = Sys.time()
        )
        
        # Update processed data
        rv$processed_data <- processed_data
        
        # Notify user
        showNotification(
          paste("Duplicates handled using", input$duplicate_handling, "method"), 
          type = "message"
        )
        
      }, error = function(e) {
        showNotification(
          paste("Error handling duplicates:", e$message), 
          type = "error"
        )
      })
    })
  })
  
  # ===== Handle Outliers =====
  observeEvent(input$apply_outliers, {
    req(rv$processed_data)
    
    withProgress(message = 'Processing outliers...', value = 0, {
      
      tryCatch({
        # Detect outliers
        data_with_outliers <- detect_outliers(
          rv$processed_data, 
          method = input$outlier_method,
          threshold = input$outlier_threshold
        )
        
        # Store outliers for visualization
        rv$outliers <- data_with_outliers %>%
          filter(is_outlier)
        
        # Apply outlier handling
        if (input$outlier_action != "keep") {
          processed_data <- data_with_outliers %>%
            group_by(Item_ID) %>%
            mutate(
              Volume = case_when(
                !is_outlier ~ Volume,
                input$outlier_action == "remove" ~ as.numeric(NA), # Will be filtered out later
                input$outlier_action == "mean" ~ mean(Volume[!is_outlier], na.rm = TRUE),
                input$outlier_action == "median" ~ median(Volume[!is_outlier], na.rm = TRUE),
                input$outlier_action == "winsorize" ~ {
                  if (outlier_severity == "High") {
                    # For high outliers, cap at upper bound (e.g., Q3 + 1.5*IQR for IQR method)
                    max(Volume[!is_outlier], na.rm = TRUE)
                  } else if (outlier_severity == "Low") {
                    # For low outliers, floor at lower bound (e.g., Q1 - 1.5*IQR for IQR method)
                    min(Volume[!is_outlier], na.rm = TRUE)
                  } else {
                    Volume
                  }
                },
                TRUE ~ Volume
              )
            ) %>%
            ungroup()
          
          # If remove option selected, filter out NA rows (the outliers)
          if (input$outlier_action == "remove") {
            processed_data <- processed_data %>%
              filter(!is.na(Volume))
          }
          
          # Update processed data
          rv$processed_data <- processed_data %>%
            select(-is_outlier, -outlier_severity)
          
        } else {
          # If keeping outliers, just update the processed_data without the outlier columns
          rv$processed_data <- data_with_outliers %>%
            select(-is_outlier, -outlier_severity)
        }
        
        # Store the processing step
        rv$preprocessing_steps$outliers <- list(
          method = input$outlier_method,
          threshold = input$outlier_threshold,
          action = input$outlier_action,
          timestamp = Sys.time()
        )
        
        # Notify user
        outlier_count <- nrow(rv$outliers)
        showNotification(
          paste("Detected", outlier_count, "outliers,", 
                "handled using", input$outlier_action, "method"), 
          type = "message"
        )
        
      }, error = function(e) {
        showNotification(
          paste("Error handling outliers:", e$message), 
          type = "error"
        )
      })
    })
  })
  
  # ===== Aggregation Preview =====
  output$aggregation_preview <- renderPlotly({
    req(rv$processed_data, rv$current_item)
    
    # Filter data for selected item
    item_data <- rv$processed_data %>%
      filter(Item_Name == rv$current_item)
    
    # Don't aggregate if "none" selected
    if (input$data_aggregation == "none") {
      return(
        plot_ly(
          data = item_data,
          x = ~Date,
          y = ~Volume,
          type = 'scatter',
          mode = 'lines+markers',
          line = list(color = '#00a65a', width = 2),
          marker = list(color = '#00a65a', size = 5),
          name = 'Original Data'
        ) %>%
          layout(
            title = list(text = paste("Original Data for", rv$current_item)),
            xaxis = list(title = "Date"),
            yaxis = list(title = "Volume"),
            hovermode = "closest",
            showlegend = TRUE
          )
      )
    }
    
    # Prepare aggregated data based on selected method
    agg_data <- NULL
    
    # Parse date components for grouping
    grouped_data <- item_data %>%
      mutate(
        Year = year(Date),
        Month = month(Date),
        Week = week(Date),
        Day = day(Date)
      )
    
    # Apply aggregation
    if (input$data_aggregation == "weekly") {
      agg_data <- grouped_data %>%
        group_by(Year, Week) %>%
        summarize(
          Date = min(Date), # Use the first day of the week
          Volume = case_when(
            input$agg_method == "sum" ~ sum(Volume, na.rm = TRUE),
            input$agg_method == "mean" ~ mean(Volume, na.rm = TRUE),
            input$agg_method == "median" ~ median(Volume, na.rm = TRUE),
            input$agg_method == "max" ~ max(Volume, na.rm = TRUE),
            input$agg_method == "min" ~ min(Volume, na.rm = TRUE),
            TRUE ~ sum(Volume, na.rm = TRUE)
          ),
          Item_ID = first(Item_ID),
          Item_Name = first(Item_Name),
          .groups = "drop"
        )
    } else if (input$data_aggregation == "monthly") {
      agg_data <- grouped_data %>%
        group_by(Year, Month) %>%
        summarize(
          Date = floor_date(min(Date), "month"), # First day of the month
          Volume = case_when(
            input$agg_method == "sum" ~ sum(Volume, na.rm = TRUE),
            input$agg_method == "mean" ~ mean(Volume, na.rm = TRUE),
            input$agg_method == "median" ~ median(Volume, na.rm = TRUE),
            input$agg_method == "max" ~ max(Volume, na.rm = TRUE),
            input$agg_method == "min" ~ min(Volume, na.rm = TRUE),
            TRUE ~ sum(Volume, na.rm = TRUE)
          ),
          Item_ID = first(Item_ID),
          Item_Name = first(Item_Name),
          .groups = "drop"
        )
    } else if (input$data_aggregation == "weekly_to_monthly") {
      # First aggregate to weekly
      weekly_data <- grouped_data %>%
        group_by(Year, Week) %>%
        summarize(
          Date = min(Date),
          Volume = case_when(
            input$agg_method == "sum" ~ sum(Volume, na.rm = TRUE),
            input$agg_method == "mean" ~ mean(Volume, na.rm = TRUE),
            input$agg_method == "median" ~ median(Volume, na.rm = TRUE),
            input$agg_method == "max" ~ max(Volume, na.rm = TRUE),
            input$agg_method == "min" ~ min(Volume, na.rm = TRUE),
            TRUE ~ sum(Volume, na.rm = TRUE)
          ),
          Month = month(Date),
          Item_ID = first(Item_ID),
          Item_Name = first(Item_Name),
          .groups = "drop"
        )
      
      # Then aggregate to monthly
      agg_data <- weekly_data %>%
        group_by(Year, Month) %>%
        summarize(
          Date = floor_date(min(Date), "month"),
          Volume = case_when(
            input$agg_method == "sum" ~ sum(Volume, na.rm = TRUE),
            input$agg_method == "mean" ~ mean(Volume, na.rm = TRUE),
            input$agg_method == "median" ~ median(Volume, na.rm = TRUE),
            input$agg_method == "max" ~ max(Volume, na.rm = TRUE),
            input$agg_method == "min" ~ min(Volume, na.rm = TRUE),
            TRUE ~ sum(Volume, na.rm = TRUE)
          ),
          Item_ID = first(Item_ID),
          Item_Name = first(Item_Name),
          .groups = "drop"
        )
    } else if (input$data_aggregation == "custom") {
      # Custom aggregation by specified period
      agg_data <- item_data %>%
        mutate(
          Period = as.integer((Date - min(Date)) / input$agg_period)
        ) %>%
        group_by(Period) %>%
        summarize(
          Date = min(Date),
          Volume = case_when(
            input$agg_method == "sum" ~ sum(Volume, na.rm = TRUE),
            input$agg_method == "mean" ~ mean(Volume, na.rm = TRUE),
            input$agg_method == "median" ~ median(Volume, na.rm = TRUE),
            input$agg_method == "max" ~ max(Volume, na.rm = TRUE),
            input$agg_method == "min" ~ min(Volume, na.rm = TRUE),
            TRUE ~ sum(Volume, na.rm = TRUE)
          ),
          Item_ID = first(Item_ID),
          Item_Name = first(Item_Name),
          .groups = "drop"
        )
    }
    
    # Create comparison plot
    p <- plot_ly() %>%
      add_trace(
        data = item_data,
        x = ~Date,
        y = ~Volume,
        type = 'scatter',
        mode = 'lines',
        line = list(color = '#3c8dbc', width = 1, dash = 'dot'),
        name = 'Original Data'
      )
    
    if (!is.null(agg_data)) {
      p <- p %>% add_trace(
        data = agg_data,
        x = ~Date,
        y = ~Volume,
        type = 'scatter',
        mode = 'lines+markers',
        line = list(color = '#00a65a', width = 2),
        marker = list(color = '#00a65a', size = 8),
        name = paste('Aggregated (', input$agg_method, ')')
      )
    }
    
    p <- p %>% layout(
      title = list(text = paste("Aggregation Preview for", rv$current_item)),
      xaxis = list(title = "Date"),
      yaxis = list(title = "Volume"),
      hovermode = "closest",
      showlegend = TRUE
    )
    
    return(p)
  })
  
  # ===== Apply Aggregation =====
  observeEvent(input$apply_aggregation, {
    req(rv$processed_data)
    
    # Only apply if aggregation is requested
    if (input$data_aggregation == "none") {
      showNotification("No aggregation applied", type = "message")
      return()
    }
    
    withProgress(message = 'Aggregating data...', value = 0, {
      
      tryCatch({
        # Create aggregated dataset
        aggregated_data <- rv$processed_data %>%
          group_by(Item_ID, Item_Name) %>%
          group_modify(~ {
            # Parse date components for grouping
            df <- .x %>%
              mutate(
                Year = year(Date),
                Month = month(Date),
                Week = week(Date),
                Day = day(Date)
              )
            
            # Apply aggregation based on selected method
            if (input$data_aggregation == "weekly") {
              df %>%
                group_by(Year, Week, .add = TRUE) %>%
                summarize(
                  Date = min(Date), # Use the first day of the week
                  Volume = case_when(
                    input$agg_method == "sum" ~ sum(Volume, na.rm = TRUE),
                    input$agg_method == "mean" ~ mean(Volume, na.rm = TRUE),
                    input$agg_method == "median" ~ median(Volume, na.rm = TRUE),
                    input$agg_method == "max" ~ max(Volume, na.rm = TRUE),
                    input$agg_method == "min" ~ min(Volume, na.rm = TRUE),
                    TRUE ~ sum(Volume, na.rm = TRUE)
                  ),
                  .groups = "drop"
                )
            } else if (input$data_aggregation == "monthly") {
              df %>%
                group_by(Year, Month, .add = TRUE) %>%
                summarize(
                  Date = floor_date(min(Date), "month"), # First day of the month
                  Volume = case_when(
                    input$agg_method == "sum" ~ sum(Volume, na.rm = TRUE),
                    input$agg_method == "mean" ~ mean(Volume, na.rm = TRUE),
                    input$agg_method == "median" ~ median(Volume, na.rm = TRUE),
                    input$agg_method == "max" ~ max(Volume, na.rm = TRUE),
                    input$agg_method == "min" ~ min(Volume, na.rm = TRUE),
                    TRUE ~ sum(Volume, na.rm = TRUE)
                  ),
                  .groups = "drop"
                )
            } else if (input$data_aggregation == "weekly_to_monthly") {
              # First aggregate to weekly
              weekly_data <- df %>%
                group_by(Year, Week, .add = TRUE) %>%
                summarize(
                  Date = min(Date),
                  Volume = case_when(
                    input$agg_method == "sum" ~ sum(Volume, na.rm = TRUE),
                    input$agg_method == "mean" ~ mean(Volume, na.rm = TRUE),
                    input$agg_method == "median" ~ median(Volume, na.rm = TRUE),
                    input$agg_method == "max" ~ max(Volume, na.rm = TRUE),
                    input$agg_method == "min" ~ min(Volume, na.rm = TRUE),
                    TRUE ~ sum(Volume, na.rm = TRUE)
                  ),
                  Month = month(Date),
                  .groups = "drop"
                )
              
              # Then aggregate to monthly
              weekly_data %>%
                group_by(Year, Month, .add = TRUE) %>%
                summarize(
                  Date = floor_date(min(Date), "month"),
                  Volume = case_when(
                    input$agg_method == "sum" ~ sum(Volume, na.rm = TRUE),
                    input$agg_method == "mean" ~ mean(Volume, na.rm = TRUE),
                    input$agg_method == "median" ~ median(Volume, na.rm = TRUE),
                    input$agg_method == "max" ~ max(Volume, na.rm = TRUE),
                    input$agg_method == "min" ~ min(Volume, na.rm = TRUE),
                    TRUE ~ sum(Volume, na.rm = TRUE)
                  ),
                  .groups = "drop"
                )
            } else if (input$data_aggregation == "custom") {
              # Custom aggregation by specified period
              df %>%
                mutate(
                  Period = as.integer((Date - min(Date)) / input$agg_period)
                ) %>%
                group_by(Period, .add = TRUE) %>%
                summarize(
                  Date = min(Date),
                  Volume = case_when(
                    input$agg_method == "sum" ~ sum(Volume, na.rm = TRUE),
                    input$agg_method == "mean" ~ mean(Volume, na.rm = TRUE),
                    input$agg_method == "median" ~ median(Volume, na.rm = TRUE),
                    input$agg_method == "max" ~ max(Volume, na.rm = TRUE),
                    input$agg_method == "min" ~ min(Volume, na.rm = TRUE),
                    TRUE ~ sum(Volume, na.rm = TRUE)
                  ),
                  .groups = "drop"
                )
            }
          }) %>%
          ungroup()
        
        # Update processed data
        rv$processed_data <- aggregated_data
        
        # Store the processing step
        rv$preprocessing_steps$aggregation <- list(
          method = input$data_aggregation,
          agg_function = input$agg_method,
          custom_period = if(input$data_aggregation == "custom") input$agg_period else NULL,
          timestamp = Sys.time()
        )
        
        # Notify user
        showNotification(
          paste("Data aggregated to", input$data_aggregation, "level using", input$agg_method), 
          type = "message"
        )
        
      }, error = function(e) {
        showNotification(
          paste("Error applying aggregation:", e$message), 
          type = "error"
        )
      })
    })
  })
  
  # ===== Transformation Preview =====
  output$transformation_preview <- renderPlotly({
    req(rv$processed_data, rv$current_item)
    
    # Filter data for selected item
    item_data <- rv$processed_data %>%
      filter(Item_Name == rv$current_item)
    
    # Don't transform if "none" selected
    if (input$transform_method == "none") {
      return(
        plot_ly(
          data = item_data,
          x = ~Date,
          y = ~Volume,
          type = 'scatter',
          mode = 'lines+markers',
          line = list(color = '#00a65a', width = 2),
          marker = list(color = '#00a65a', size = 5),
          name = 'Original Data'
        ) %>%
          layout(
            title = list(text = paste("Original Data for", rv$current_item)),
            xaxis = list(title = "Date"),
            yaxis = list(title = "Volume"),
            hovermode = "closest",
            showlegend = TRUE
          )
      )
    }
    
    # Apply transformation for preview
    transformed_data <- item_data %>%
      mutate(
        Transformed_Volume = case_when(
          input$transform_method == "log" ~ log(pmax(Volume, 0.01)), # Ensure positive values for log
          input$transform_method == "sqrt" ~ sqrt(pmax(Volume, 0)),
          input$transform_method == "boxcox" ~ {
            if (min(Volume, na.rm = TRUE) <= 0) {
              # Add a constant to make all values positive for Box-Cox
              offset <- abs(min(Volume, na.rm = TRUE)) + 1
              forecast::BoxCox(Volume + offset, lambda = input$lambda)
            } else {
              forecast::BoxCox(Volume, lambda = input$lambda)
            }
          },
          input$transform_method == "zscore" ~ scale(Volume),
          input$transform_method == "minmax" ~ {
            (Volume - min(Volume, na.rm = TRUE)) / 
              (max(Volume, na.rm = TRUE) - min(Volume, na.rm = TRUE))
          },
          TRUE ~ Volume
        )
      )
    
    # Create comparison plot
    p <- plot_ly() %>%
      add_trace(
        data = transformed_data,
        x = ~Date,
        y = ~Volume,
        type = 'scatter',
        mode = 'lines',
        line = list(color = '#3c8dbc', width = 2),
        name = 'Original Data'
      ) %>%
      add_trace(
        data = transformed_data,
        x = ~Date,
        y = ~Transformed_Volume,
        type = 'scatter',
        mode = 'lines',
        line = list(color = '#00a65a', width = 2),
        name = 'Transformed Data'
      ) %>%
      layout(
        title = list(text = paste("Transformation Preview for", rv$current_item)),
        xaxis = list(title = "Date"),
        yaxis = list(title = "Volume"),
        hovermode = "closest",
        showlegend = TRUE
      )
    
    return(p)
  })
  
  # ===== Apply Transformation =====
  observeEvent(input$apply_transform, {
    req(rv$processed_data)
    
    # Only apply if transformation is requested
    if (input$transform_method == "none") {
      showNotification("No transformation applied", type = "message")
      return()
    }
    
    withProgress(message = 'Transforming data...', value = 0, {
      
      tryCatch({
        # Apply transformation to all items
        transformed_data <- rv$processed_data %>%
          group_by(Item_ID) %>%
          mutate(
            # Store original values for potential reverse transformation
            Original_Volume = Volume,
            Volume = case_when(
              input$transform_method == "log" ~ log(pmax(Volume, 0.01)), # Ensure positive values for log
              input$transform_method == "sqrt" ~ sqrt(pmax(Volume, 0)),
              input$transform_method == "boxcox" ~ {
                if (min(Volume, na.rm = TRUE) <= 0) {
                  # Add a constant to make all values positive for Box-Cox
                  offset <- abs(min(Volume, na.rm = TRUE)) + 1
                  forecast::BoxCox(Volume + offset, lambda = input$lambda)
                } else {
                  forecast::BoxCox(Volume, lambda = input$lambda)
                }
              },
              input$transform_method == "zscore" ~ as.numeric(scale(Volume)),
              input$transform_method == "minmax" ~ {
                (Volume - min(Volume, na.rm = TRUE)) / 
                  (max(Volume, na.rm = TRUE) - min(Volume, na.rm = TRUE))
              },
              TRUE ~ Volume
            )
          ) %>%
          ungroup()
        
        # Update processed data
        rv$processed_data <- transformed_data
        
        # Store the processing step
        rv$preprocessing_steps$transformation <- list(
          method = input$transform_method,
          lambda = if(input$transform_method == "boxcox") input$lambda else NULL,
          timestamp = Sys.time()
        )
        
        # Notify user
        showNotification(
          paste("Data transformed using", input$transform_method, "method"), 
          type = "message"
        )
        
      }, error = function(e) {
        showNotification(
          paste("Error applying transformation:", e$message), 
          type = "error"
        )
      })
    })
  })
  
  # ===== Seasonal Decomposition =====
  output$seasonal_decomposition <- renderPlotly({
    req(rv$processed_data, rv$current_item)
    
    # Filter data for selected item
    item_data <- rv$processed_data %>%
      filter(Item_Name == rv$current_item) %>%
      arrange(Date)
    
    # Check if we have enough data for decomposition
    min_periods <- if (input$frequency == 1) 14 else as.numeric(input$frequency) * 2
    
    if (nrow(item_data) < min_periods) {
      return(
        plot_ly() %>%
          layout(
            title = "Not enough data for seasonal decomposition",
            annotations = list(
              x = 0.5,
              y = 0.5,
              text = paste("Need at least", min_periods, "data points for decomposition"),
              showarrow = FALSE,
              font = list(size = 16)
            )
          )
      )
    }
    
    # Create time series object
    ts_data <- ts(
      item_data$Volume, 
      frequency = as.numeric(input$frequency)
    )
    
    # Perform decomposition based on method
    tryCatch({
      if (input$seasonality_method == "decompose") {
        # Use classical decomposition
        decomp <- decompose(
          ts_data, 
          type = if (input$adjust_seasonality && input$seasonal_type == "Multiplicative") "multiplicative" else "additive"
        )
        
        # Create subplot with all components
        p <- plot_ly() %>%
          subplot(
            # Original series
            plot_ly(x = item_data$Date, y = ts_data, type = 'scatter', mode = 'lines', 
                    name = 'Original', line = list(color = '#3c8dbc')) %>%
              layout(yaxis = list(title = "Original")),
            
            # Trend component
            plot_ly(x = item_data$Date, y = decomp$trend, type = 'scatter', mode = 'lines', 
                    name = 'Trend', line = list(color = '#00a65a')) %>%
              layout(yaxis = list(title = "Trend")),
            
            # Seasonal component
            plot_ly(x = item_data$Date, y = decomp$seasonal, type = 'scatter', mode = 'lines', 
                    name = 'Seasonal', line = list(color = '#f39c12')) %>%
              layout(yaxis = list(title = "Seasonal")),
            
            # Remainder component
            plot_ly(x = item_data$Date, y = decomp$random, type = 'scatter', mode = 'lines', 
                    name = 'Remainder', line = list(color = '#dd4b39')) %>%
              layout(yaxis = list(title = "Remainder")),
            
            nrows = 4,
            heights = c(0.25, 0.25, 0.25, 0.25),
            shareX = TRUE,
            titleY = TRUE
          ) %>%
          layout(
            title = paste("Classical Decomposition for", rv$current_item),
            showlegend = FALSE
          )
        
        return(p)
      } else if (input$seasonality_method == "stl") {
        # Use STL decomposition (more robust)
        decomp <- stl(ts_data, s.window = "periodic")
        
        # Create subplot with all components
        p <- plot_ly() %>%
          subplot(
            # Original series
            plot_ly(x = item_data$Date, y = ts_data, type = 'scatter', mode = 'lines', 
                    name = 'Original', line = list(color = '#3c8dbc')) %>%
              layout(yaxis = list(title = "Original")),
            
            # Trend component
            plot_ly(x = item_data$Date, y = decomp$time.series[, "trend"], type = 'scatter', mode = 'lines', 
                    name = 'Trend', line = list(color = '#00a65a')) %>%
              layout(yaxis = list(title = "Trend")),
            
            # Seasonal component
            plot_ly(x = item_data$Date, y = decomp$time.series[, "seasonal"], type = 'scatter', mode = 'lines', 
                    name = 'Seasonal', line = list(color = '#f39c12')) %>%
              layout(yaxis = list(title = "Seasonal")),
            
            # Remainder component
            plot_ly(x = item_data$Date, y = decomp$time.series[, "remainder"], type = 'scatter', mode = 'lines', 
                    name = 'Remainder', line = list(color = '#dd4b39')) %>%
              layout(yaxis = list(title = "Remainder")),
            
            nrows = 4,
            heights = c(0.25, 0.25, 0.25, 0.25),
            shareX = TRUE,
            titleY = TRUE
          ) %>%
          layout(
            title = paste("STL Decomposition for", rv$current_item),
            showlegend = FALSE
          )
        
        return(p)
      } else if (input$seasonality_method == "ma") {
        # Use moving average
        freq <- as.numeric(input$frequency)
        ma <- stats::filter(ts_data, filter = rep(1/freq, freq), sides = 2)
        
        # Create subplot
        p <- plot_ly() %>%
          subplot(
            # Original series
            plot_ly(x = item_data$Date, y = ts_data, type = 'scatter', mode = 'lines', 
                    name = 'Original', line = list(color = '#3c8dbc')) %>%
              layout(yaxis = list(title = "Original")),
            
            # Moving average (trend)
            plot_ly(x = item_data$Date, y = ma, type = 'scatter', mode = 'lines', 
                    name = 'Moving Avg', line = list(color = '#00a65a')) %>%
              layout(yaxis = list(title = "Moving Avg")),
            
            # Detrended series
            plot_ly(x = item_data$Date, y = ts_data - ma, type = 'scatter', mode = 'lines', 
                    name = 'Detrended', line = list(color = '#f39c12')) %>%
              layout(yaxis = list(title = "Detrended")),
            
            nrows = 3,
            heights = c(0.34, 0.33, 0.33),
            shareX = TRUE,
            titleY = TRUE
          ) %>%
          layout(
            title = paste("Moving Average Decomposition for", rv$current_item),
            showlegend = FALSE
          )
        
        return(p)
      } else {
        # No decomposition, just show original series
        return(
          plot_ly(
            x = item_data$Date,
            y = item_data$Volume,
            type = 'scatter',
            mode = 'lines',
            line = list(color = '#3c8dbc')
          ) %>%
            layout(
              title = paste("Time Series for", rv$current_item),
              xaxis = list(title = "Date"),
              yaxis = list(title = "Volume")
            )
        )
      }
    }, error = function(e) {
      return(
        plot_ly() %>%
          layout(
            title = "Error in seasonal decomposition",
            annotations = list(
              x = 0.5,
              y = 0.5,
              text = paste("Error:", e$message),
              showarrow = FALSE,
              font = list(size = 16)
            )
          )
      )
    })
  })
  
  # ===== Apply Seasonal Adjustment =====
  observeEvent(input$apply_seasonal, {
    req(rv$processed_data)
    
    # Only apply if seasonal adjustment is requested
    if (!input$adjust_seasonality || input$seasonality_method == "none") {
      showNotification("No seasonal adjustment applied", type = "message")
      return()
    }
    
    withProgress(message = 'Adjusting seasonality...', value = 0, {
      
      tryCatch({
        # Apply seasonal adjustment to each item separately
        adjusted_data <- rv$processed_data %>%
          group_by(Item_ID) %>%
          group_modify(~ {
            item_data <- .x %>% arrange(Date)
            
            # Check if enough data for decomposition
            freq <- as.numeric(input$frequency)
            min_periods <- if (freq == 1) 14 else freq * 2
            
            if (nrow(item_data) < min_periods) {
              # Not enough data, return as is
              return(item_data)
            }
            
            # Create time series
            ts_data <- ts(item_data$Volume, frequency = freq)
            
            # Store original values
            item_data$Original_Volume <- item_data$Volume
            
            # Perform decomposition and adjustment
            if (input$seasonality_method == "decompose") {
              # Classical decomposition
              decomp_type <- if (input$seasonal_type == "Multiplicative") "multiplicative" else "additive"
              decomp <- decompose(ts_data, type = decomp_type)
              
              if (decomp_type == "additive") {
                # For additive, subtract seasonal component
                item_data$Volume <- ts_data - decomp$seasonal
              } else {
                # For multiplicative, divide by seasonal component
                item_data$Volume <- ts_data / decomp$seasonal
              }
            } else if (input$seasonality_method == "stl") {
              # STL decomposition (always additive)
              decomp <- stl(ts_data, s.window = "periodic")
              # Subtract seasonal component
              item_data$Volume <- ts_data - decomp$time.series[, "seasonal"]
            } else if (input$seasonality_method == "ma") {
              # Moving average approach
              ma <- stats::filter(ts_data, filter = rep(1/freq, freq), sides = 2)
              # Replace with trend (moving average)
              item_data$Volume <- ma
              # Fill NAs at edges with original values
              na_idx <- is.na(item_data$Volume)
              item_data$Volume[na_idx] <- item_data$Original_Volume[na_idx]
            }
            
            return(item_data)
          }) %>%
          ungroup()
        
        # Update processed data
        rv$processed_data <- adjusted_data
        
        # Store the processing step
        rv$preprocessing_steps$seasonality <- list(
          method = input$seasonality_method,
          seasonal_type = if (input$adjust_seasonality) input$seasonal_type else NULL,
          frequency = as.numeric(input$frequency),
          timestamp = Sys.time()
        )
        
        # Notify user
        showNotification(
          paste("Seasonal adjustment applied using", input$seasonality_method, "method"), 
          type = "message"
        )
        
      }, error = function(e) {
        showNotification(
          paste("Error applying seasonal adjustment:", e$message), 
          type = "error"
        )
      })
    })
  })
  
  # ===== Preprocessing Summary =====
  output$preprocessing_summary <- renderPrint({
    req(rv$preprocessing_steps)
    
    if (length(rv$preprocessing_steps) == 0) {
      cat("No preprocessing steps applied yet.")
      return()
    }
    
    cat("Applied Preprocessing Steps:\n\n")
    
    for (step_name in names(rv$preprocessing_steps)) {
      step <- rv$preprocessing_steps[[step_name]]
      
      if (step_name == "missing_values") {
        cat("Missing Values: ", step$method, "\n")
      } else if (step_name == "duplicates") {
        cat("Duplicates: ", step$method, "\n")
      } else if (step_name == "outliers") {
        cat("Outliers: ", step$method, " (threshold = ", step$threshold, "), action: ", step$action, "\n", sep = "")
      } else if (step_name == "aggregation") {
        cat("Aggregation: ", step$method, " using ", step$agg_function, "\n", sep = "")
        if (!is.null(step$custom_period)) {
          cat("  Custom period: ", step$custom_period, " days\n", sep = "")
        }
      } else if (step_name == "transformation") {
        cat("Transformation: ", step$method, "\n", sep = "")
        if (!is.null(step$lambda)) {
          cat("  Lambda: ", step$lambda, "\n", sep = "")
        }
      } else if (step_name == "seasonality") {
        cat("Seasonality: ", step$method, "\n", sep = "")
        if (!is.null(step$seasonal_type)) {
          cat("  Type: ", step$seasonal_type, "\n", sep = "")
        }
        cat("  Frequency: ", step$frequency, "\n", sep = "")
      }
      
      # Add timestamp
      cat("  Applied at: ", format(step$timestamp, "%Y-%m-%d %H:%M:%S"), "\n\n", sep = "")
    }
  })
  
  
  
  # ===== Data Status Indicators =====
  output$data_status_indicators <- renderUI({
    req(rv$processed_data)
    
    # Calculate stats
    missing_count <- sum(is.na(rv$processed_data$Volume))
    total_count <- nrow(rv$processed_data)
    missing_pct <- missing_count / total_count * 100
    
    # Outlier count (if available)
    outlier_count <- if (!is.null(rv$outliers)) nrow(rv$outliers) else 0
    outlier_pct <- outlier_count / total_count * 100
    
    # Create status indicators
    tagList(
      div(class = "progress-card",
          strong("Data Overview:"),
          p(
            "Records: ", total_count,
            ", Items: ", length(unique(rv$processed_data$Item_ID)),
            ", Date Range: ", format(min(rv$processed_data$Date, na.rm = TRUE), "%Y-%m-%d"), 
            " to ", format(max(rv$processed_data$Date, na.rm = TRUE), "%Y-%m-%d")
          )
      ),
      
      div(class = "progress-card",
          strong("Missing Values:"),
          div(class = "progress",
              div(class = "progress-bar",
                  id = "missing_progress_bar",
                  role = "progressbar",
                  style = if(missing_count > 0) {
                    paste0("width: ", min(missing_pct * 5, 100), "%; ",
                           "background-color: ", if(missing_pct > 10) "#dd4b39" else "#f39c12")
                  } else {
                    "width: 100%; background-color: #00a65a"
                  }
              )
          ),
          p(
            missing_count, " missing values (", round(missing_pct, 2), "%)",
            if (missing_count == 0) icon("check", class = "text-success") else NULL
          )
      ),
      
      div(class = "progress-card",
          strong("Outliers:"),
          div(class = "progress",
              div(class = "progress-bar",
                  id = "outlier_progress_bar",
                  role = "progressbar",
                  style = if(outlier_count > 0) {
                    paste0("width: ", min(outlier_pct * 10, 100), "%; ",
                           "background-color: ", if(outlier_pct > 5) "#dd4b39" else "#f39c12")
                  } else {
                    "width: 100%; background-color: #00a65a"
                  }
              )
          ),
          p(
            outlier_count, " outliers (", round(outlier_pct, 2), "%)",
            if (outlier_count == 0) icon("check", class = "text-success") else NULL
          )
      ),
      
      div(class = "progress-card",
          strong("Preprocessing Applied:"),
          div(class = "progress",
              div(class = "progress-bar bg-info",
                  id = "preprocessing_progress_bar",
                  role = "progressbar",
                  style = paste0("width: ", min(length(rv$preprocessing_steps) * 20, 100), "%")
              )
          ),
          p(
            length(rv$preprocessing_steps), " preprocessing steps applied"
          )
      )
    )
  })
  
  # ===== Item Statistics =====
  output$stats_n_obs <- renderValueBox({
    req(rv$processed_data, rv$current_item)
    
    item_data <- rv$processed_data %>%
      filter(Item_Name == rv$current_item)
    
    valueBox(
      nrow(item_data),
      "Observations",
      icon = icon("list"),
      color = "blue",
      width = 12
    )
  })
  
  output$stats_mean <- renderValueBox({
    req(rv$processed_data, rv$current_item)
    
    item_data <- rv$processed_data %>%
      filter(Item_Name == rv$current_item)
    
    valueBox(
      round(mean(item_data$Volume, na.rm = TRUE), 2),
      "Mean Volume",
      icon = icon("calculator"),
      color = "blue",
      width = 12
    )
  })
  
  output$stats_stdev <- renderValueBox({
    req(rv$processed_data, rv$current_item)
    
    item_data <- rv$processed_data %>%
      filter(Item_Name == rv$current_item)
    
    valueBox(
      round(sd(item_data$Volume, na.rm = TRUE), 2),
      "Standard Deviation",
      icon = icon("chart-line"),
      color = "blue",
      width = 12
    )
  })
  
  output$stats_missing <- renderValueBox({
    req(rv$processed_data, rv$current_item)
    
    item_data <- rv$processed_data %>%
      filter(Item_Name == rv$current_item)
    
    missing_count <- sum(is.na(item_data$Volume))
    missing_pct <- missing_count / nrow(item_data) * 100
    
    valueBox(
      paste0(missing_count, " (", round(missing_pct, 1), "%)"),
      "Missing Values",
      icon = icon("question-circle"),
      color = if(missing_count > 0) "yellow" else "green",
      width = 12
    )
  })
  
  output$stats_outliers <- renderValueBox({
    req(rv$processed_data, rv$current_item)
    
    if (is.null(rv$outliers)) {
      outlier_count <- 0
      outlier_pct <- 0
    } else {
      item_data <- rv$processed_data %>%
        filter(Item_Name == rv$current_item)
      
      outlier_data <- rv$outliers %>%
        filter(Item_Name == rv$current_item)
      
      outlier_count <- nrow(outlier_data)
      outlier_pct <- outlier_count / nrow(item_data) * 100
    }
    
    valueBox(
      paste0(outlier_count, " (", round(outlier_pct, 1), "%)"),
      "Outliers",
      icon = icon("exclamation-triangle"),
      color = if(outlier_count > 0) "orange" else "green",
      width = 12
    )
  })
  
  # ===== Apply All Preprocessing =====
  observeEvent(input$apply_preprocessing, {
    req(rv$processed_data)
    
    if (length(rv$preprocessing_steps) == 0) {
      showNotification("No preprocessing steps to apply", type = "warning")
      return()
    }
    
    showNotification("All preprocessing steps have been applied to the data", type = "message")
  })
  
  # ===== Reset Preprocessing =====
  observeEvent(input$reset_preprocessing, {
    req(rv$data)
    
    # Reset to original data
    rv$processed_data <- rv$data
    
    # Clear preprocessing steps
    rv$preprocessing_steps <- list()
    
    # Clear outliers
    rv$outliers <- NULL
    
    # Notify user
    showNotification("Data reset to original state", type = "warning")
  })
  
  # ===== Download Preprocessed Data =====
  output$download_preprocessed <- downloadHandler(
    filename = function() {
      paste0("preprocessed_data_", Sys.Date(), ".xlsx")
    },
    content = function(file) {
      req(rv$processed_data)
      
      # Prepare data for export
      export_data <- rv$processed_data
      
      # Add preprocessing info
      preprocessing_info <- data.frame(
        Step = character(),
        Details = character(),
        Timestamp = character(),
        stringsAsFactors = FALSE
      )
      
      for (step_name in names(rv$preprocessing_steps)) {
        step <- rv$preprocessing_steps[[step_name]]
        
        details <- ""
        
        if (step_name == "missing_values") {
          details <- paste("Method:", step$method)
        } else if (step_name == "duplicates") {
          details <- paste("Method:", step$method)
        } else if (step_name == "outliers") {
          details <- paste("Method:", step$method, "Threshold:", step$threshold, "Action:", step$action)
        } else if (step_name == "aggregation") {
          details <- paste("Method:", step$method, "Function:", step$agg_function)
          if (!is.null(step$custom_period)) {
            details <- paste(details, "Period:", step$custom_period)
          }
        } else if (step_name == "transformation") {
          details <- paste("Method:", step$method)
          if (!is.null(step$lambda)) {
            details <- paste(details, "Lambda:", step$lambda)
          }
        } else if (step_name == "seasonality") {
          details <- paste("Method:", step$method)
          if (!is.null(step$seasonal_type)) {
            details <- paste(details, "Type:", step$seasonal_type)
          }
          details <- paste(details, "Frequency:", step$frequency)
        }
        
        preprocessing_info <- rbind(
          preprocessing_info,
          data.frame(
            Step = step_name,
            Details = details,
            Timestamp = format(step$timestamp, "%Y-%m-%d %H:%M:%S"),
            stringsAsFactors = FALSE
          )
        )
      }
      
      # Create a list of sheets
      sheets_list <- list(
        "Data" = export_data,
        "Preprocessing_Info" = preprocessing_info
      )
      
      # Add outliers if available
      if (!is.null(rv$outliers) && nrow(rv$outliers) > 0) {
        sheets_list[["Outliers"]] <- rv$outliers
      }
      
      # Write to Excel
      write_xlsx(sheets_list, file)
    }
  ) #
  
  # =====================
  # Forecasting Functions
  # =====================
  
  # ===== Forecast Preview =====
  output$forecast_preview <- renderPlotly({
    req(rv$processed_data, input$forecast_item)
    
    # Filter data for selected item
    item_data <- rv$processed_data %>%
      filter(Item_Name == input$forecast_item) %>%
      arrange(Date)
    
    # Check if enough data
    if (nrow(item_data) < 5) {
      return(
        plot_ly() %>%
          layout(
            title = "Not enough data for forecast preview",
            annotations = list(
              x = 0.5,
              y = 0.5,
              text = "Need at least 5 data points for forecasting",
              showarrow = FALSE,
              font = list(size = 16)
            )
          )
      )
    }
    
    # Create time series object
    ts_data <- ts(
      item_data$Volume, 
      frequency = as.numeric(input$frequency)
    )
    
    # Prepare forecast
    horizon <- min(input$h_value, 10)  # Limit preview to 10 periods
    forecast_result <- NULL
    
    tryCatch({
      if (input$method == "ARIMA") {
        if (input$auto_arima) {
          fit <- auto.arima(ts_data)
        } else {
          # Use manual parameters
          if (input$seasonal_arima) {
            fit <- Arima(ts_data, 
                         order = c(input$p_value, input$d_value, input$q_value),
                         seasonal = list(order = c(input$P_value, input$D_value, input$Q_value), 
                                         period = input$S_value))
          } else {
            fit <- Arima(ts_data, 
                         order = c(input$p_value, input$d_value, input$q_value))
          }
        }
        
        forecast_result <- forecast(fit, h = horizon)
      } else if (input$method == "Exponential Smoothing") {
        if (input$auto_ets) {
          fit <- ets(ts_data)
        } else {
          # Use manual parameters
          model <- input$ets_model
          fit <- ets(ts_data, model = model, 
                     alpha = input$alpha, 
                     beta = input$beta, 
                     gamma = input$gamma)
        }
        
        forecast_result <- forecast(fit, h = horizon)
      } else if (input$method == "Prophet") {
        # Prepare data for Prophet
        prophet_data <- data.frame(
          ds = item_data$Date,
          y = item_data$Volume
        )
        
        # Configure Prophet model
        fit <- prophet(
          prophet_data,
          changepoint.prior.scale = input$changepoint_prior,
          seasonality.prior.scale = input$seasonality_prior,
          yearly.seasonality = input$yearly_seasonality,
          weekly.seasonality = input$weekly_seasonality,
          daily.seasonality = input$daily_seasonality
        )
        
        # Include holidays if requested
        if (input$include_holidays) {
          fit <- add_country_holidays(fit, country = input$holiday_country)
        }
        
        # Make future dataframe
        future <- make_future_dataframe(fit, periods = horizon, freq = "day")
        
        # Generate forecast
        prophet_forecast <- predict(fit, future)
        
        # Format output to match other methods
        forecast_dates <- tail(prophet_forecast$ds, horizon)
        forecast_values <- tail(prophet_forecast$yhat, horizon)
        lower_bound <- tail(prophet_forecast$yhat_lower, horizon)
        upper_bound <- tail(prophet_forecast$yhat_upper, horizon)
        
        # Manually create a structure similar to forecast objects
        forecast_result <- list(
          mean = forecast_values,
          lower = cbind(lower_bound),
          upper = cbind(upper_bound),
          x = ts_data,
          method = "Prophet"
        )
        
        class(forecast_result) <- "forecast"
      }
      
      # Create plot
      if (!is.null(forecast_result)) {
        # Determine date range for forecast
        last_date <- max(item_data$Date)
        forecast_dates <- seq.Date(
          from = last_date + days(1),
          by = "day",
          length.out = horizon
        )
        
        # Create base plot with historical data
        p <- plot_ly() %>%
          add_trace(
            x = item_data$Date,
            y = item_data$Volume,
            type = 'scatter',
            mode = 'lines',
            line = list(color = '#3c8dbc', width = 2),
            name = 'Historical'
          )
        
        # Add forecast
        p <- p %>%
          add_trace(
            x = forecast_dates,
            y = forecast_result$mean,
            type = 'scatter',
            mode = 'lines',
            line = list(color = '#00a65a', width = 2, dash = 'dash'),
            name = 'Forecast'
          )
        
        # Add prediction intervals if requested
        if (input$use_prediction_intervals) {
          # Determine which interval to use (80% or 95%)
          interval_idx <- if (input$prediction_interval <= 80) 1 else 2
          
          # For Prophet, we already have the bounds
          if (input$method == "Prophet") {
            lower_bounds <- forecast_result$lower
            upper_bounds <- forecast_result$upper
          } else {
            lower_bounds <- forecast_result$lower[, interval_idx]
            upper_bounds <- forecast_result$upper[, interval_idx]
          }
          
          # Add interval as a shaded area
          p <- p %>%
            add_trace(
              x = c(forecast_dates, rev(forecast_dates)),
              y = c(lower_bounds, rev(upper_bounds)),
              type = 'scatter',
              mode = 'lines',
              fill = 'toself',
              fillcolor = 'rgba(0, 166, 90, 0.2)',
              line = list(color = 'transparent'),
              showlegend = FALSE,
              name = paste0(input$prediction_interval, "% Interval")
            )
        }
        
        # Finalize layout
        p <- p %>%
          layout(
            title = paste("Forecast Preview for", input$forecast_item),
            xaxis = list(title = "Date"),
            yaxis = list(title = "Volume"),
            hovermode = "closest",
            showlegend = TRUE
          )
        
        return(p)
      } else {
        return(
          plot_ly() %>%
            layout(
              title = "No forecast generated",
              annotations = list(
                x = 0.5,
                y = 0.5,
                text = "Unable to generate forecast preview",
                showarrow = FALSE,
                font = list(size = 16)
              )
            )
        )
      }
    }, error = function(e) {
      return(
        plot_ly() %>%
          layout(
            title = "Error in forecast preview",
            annotations = list(
              x = 0.5,
              y = 0.5,
              text = paste("Error:", e$message),
              showarrow = FALSE,
              font = list(size = 16)
            )
          )
      )
    })
  })
  
  # ===== Update Preview =====
  observeEvent(input$update_preview, {
    # Just trigger the preview to refresh
    showNotification("Updating forecast preview...", type = "message")
  })
  
  # ===== Helper function to calculate performance metrics =====
  calculate_metrics <- function(actual, predicted) {
    # Ensure vectors are of same length
    min_length <- min(length(actual), length(predicted))
    actual <- actual[1:min_length]
    predicted <- predicted[1:min_length]
    
    # Remove any NA values
    valid_idx <- !is.na(actual) & !is.na(predicted)
    if (sum(valid_idx) == 0) {
      return(list(MAE = NA, RMSE = NA, MAPE = NA))
    }
    
    actual <- actual[valid_idx]
    predicted <- predicted[valid_idx]
    
    # Calculate metrics
    mae <- mean(abs(actual - predicted))
    rmse <- sqrt(mean((actual - predicted)^2))
    
    # Handle zero values in actual for MAPE calculation
    if (any(actual == 0)) {
      # Modified MAPE to handle zeros
      non_zero <- actual != 0
      if (sum(non_zero) > 0) {
        mape <- mean(abs((actual[non_zero] - predicted[non_zero]) / actual[non_zero])) * 100
      } else {
        mape <- NA
      }
    } else {
      mape <- mean(abs((actual - predicted) / actual)) * 100
    }
    
    return(list(
      MAE = round(mae, 2),
      RMSE = round(rmse, 2),
      MAPE = round(mape, 2)
    ))
  }
  
  # ===== Run Forecast =====
  observeEvent(input$go, {
    req(rv$processed_data)
    
    withProgress(message = 'Running forecasts...', value = 0, {
      
      tryCatch({
        # Determine which items to forecast
        if (input$forecast_all_items || input$batch_forecast) {
          items_to_forecast <- unique(rv$processed_data$Item_Name)
        } else {
          items_to_forecast <- input$forecast_item
        }
        
        # Initialize results structures
        forecast_results <- data.frame()
        performance_metrics <- list()
        model_objects <- list()
        
        # Set number of steps based on progress bar
        total_steps <- length(items_to_forecast)
        step_size <- 1 / total_steps
        
        # Loop through each item
        for (i in 1:total_steps) {
          # Update progress
          incProgress(step_size, detail = paste("Forecasting item", i, "of", total_steps))
          
          current_item <- items_to_forecast[i]
          
          # Filter data for current item
          item_data <- rv$processed_data %>%
            filter(Item_Name == current_item) %>%
            arrange(Date)
          
          # Skip if not enough data
          if (nrow(item_data) < 5) {
            showNotification(paste("Skipping", current_item, "- not enough data"), type = "warning")
            next
          }
          
          # Create time series object
          ts_data <- ts(
            item_data$Volume, 
            frequency = as.numeric(input$frequency)
          )
          
          # Set forecast horizon
          horizon <- input$h_value
          
          # Generate forecast based on selected method
          forecast_result <- NULL
          
          if (input$method == "ARIMA") {
            if (input$auto_arima) {
              fit <- auto.arima(ts_data)
            } else {
              # Use manual parameters
              if (input$seasonal_arima) {
                fit <- Arima(ts_data, 
                             order = c(input$p_value, input$d_value, input$q_value),
                             seasonal = list(order = c(input$P_value, input$D_value, input$Q_value), 
                                             period = input$S_value))
              } else {
                fit <- Arima(ts_data, 
                             order = c(input$p_value, input$d_value, input$q_value))
              }
            }
            
            forecast_result <- forecast(fit, h = horizon)
            model_objects[[current_item]] <- fit
          } else if (input$method == "Exponential Smoothing") {
            if (input$auto_ets) {
              fit <- ets(ts_data)
            } else {
              # Use manual parameters
              model <- input$ets_model
              fit <- ets(ts_data, model = model, 
                         alpha = input$alpha, 
                         beta = input$beta, 
                         gamma = input$gamma)
            }
            
            forecast_result <- forecast(fit, h = horizon)
            model_objects[[current_item]] <- fit
          } else if (input$method == "Prophet") {
            # Prepare data for Prophet
            prophet_data <- data.frame(
              ds = item_data$Date,
              y = item_data$Volume
            )
            
            # Configure Prophet model
            fit <- prophet(
              prophet_data,
              changepoint.prior.scale = input$changepoint_prior,
              seasonality.prior.scale = input$seasonality_prior,
              yearly.seasonality = input$yearly_seasonality,
              weekly.seasonality = input$weekly_seasonality,
              daily.seasonality = input$daily_seasonality
            )
            
            # Include holidays if requested
            if (input$include_holidays) {
              fit <- add_country_holidays(fit, country = input$holiday_country)
            }
            
            # Make future dataframe
            future <- make_future_dataframe(fit, periods = horizon, freq = "day")
            
            # Generate forecast
            prophet_forecast <- predict(fit, future)
            
            # Store model
            model_objects[[current_item]] <- list(
              model = fit,
              forecast = prophet_forecast
            )
            
            # Extract forecast values
            forecast_dates <- tail(prophet_forecast$ds, horizon)
            forecast_values <- tail(prophet_forecast$yhat, horizon)
            
            # Calculate prediction intervals
            lower_bound <- tail(prophet_forecast$yhat_lower, horizon)
            upper_bound <- tail(prophet_forecast$yhat_upper, horizon)
            
            # Create a data frame for results
            prophet_results <- data.frame(
              Date = forecast_dates,
              Forecast = forecast_values,
              Lower = lower_bound,
              Upper = upper_bound
            )
            
            # Format as a forecast object for consistent processing
            forecast_result <- list(
              mean = forecast_values,
              lower = cbind(lower_bound),
              upper = cbind(upper_bound),
              x = ts_data,
              method = "Prophet"
            )
            
            class(forecast_result) <- "forecast"
          }
          
          # Process forecast results
          if (!is.null(forecast_result)) {
            # Determine date range for forecast
            last_date <- max(item_data$Date)
            forecast_dates <- seq.Date(
              from = last_date + days(1),
              by = "day",
              length.out = horizon
            )
            
            # Create data frame for this item's forecast
            item_forecast <- data.frame(
              Date = forecast_dates,
              Forecast = as.numeric(forecast_result$mean),
              Item_ID = unique(item_data$Item_ID),
              Item_Name = current_item
            )
            
            # Add prediction intervals
            if (input$use_prediction_intervals) {
              interval_idx <- if (input$prediction_interval <= 80) 1 else 2
              
              if (input$method == "Prophet") {
                item_forecast$Lower <- as.numeric(forecast_result$lower)
                item_forecast$Upper <- as.numeric(forecast_result$upper)
              } else {
                item_forecast$Lower <- as.numeric(forecast_result$lower[, interval_idx])
                item_forecast$Upper <- as.numeric(forecast_result$upper[, interval_idx])
              }
            }
            
            # Append to results
            forecast_results <- rbind(forecast_results, item_forecast)
            
            # Calculate performance metrics if possible
            if (nrow(item_data) > horizon) {
              # Use the last part of the historical data as a test set
              test_size <- min(horizon, floor(nrow(item_data) / 3))
              train_data <- head(item_data, -test_size)
              test_data <- tail(item_data, test_size)
              
              # Re-fit and forecast
              if (input$method == "ARIMA") {
                if (input$auto_arima) {
                  test_fit <- auto.arima(ts(train_data$Volume, frequency = as.numeric(input$frequency)))
                } else {
                  if (input$seasonal_arima) {
                    test_fit <- Arima(ts(train_data$Volume, frequency = as.numeric(input$frequency)),
                                      order = c(input$p_value, input$d_value, input$q_value),
                                      seasonal = list(order = c(input$P_value, input$D_value, input$Q_value),
                                                      period = input$S_value))
                  } else {
                    test_fit <- Arima(ts(train_data$Volume, frequency = as.numeric(input$frequency)),
                                      order = c(input$p_value, input$d_value, input$q_value))
                  }
                }
                
                test_forecast <- forecast(test_fit, h = test_size)
                predicted <- as.numeric(test_forecast$mean)
              } else if (input$method == "Exponential Smoothing") {
                if (input$auto_ets) {
                  test_fit <- ets(ts(train_data$Volume, frequency = as.numeric(input$frequency)))
                } else {
                  test_fit <- ets(ts(train_data$Volume, frequency = as.numeric(input$frequency)),
                                  model = input$ets_model,
                                  alpha = input$alpha,
                                  beta = input$beta,
                                  gamma = input$gamma)
                }
                
                test_forecast <- forecast(test_fit, h = test_size)
                predicted <- as.numeric(test_forecast$mean)
              } else if (input$method == "Prophet") {
                # Prepare train data for Prophet
                prophet_train <- data.frame(
                  ds = train_data$Date,
                  y = train_data$Volume
                )
                
                # Configure Prophet model
                test_fit <- prophet(
                  prophet_train,
                  changepoint.prior.scale = input$changepoint_prior,
                  seasonality.prior.scale = input$seasonality_prior,
                  yearly.seasonality = input$yearly_seasonality,
                  weekly.seasonality = input$weekly_seasonality,
                  daily.seasonality = input$daily_seasonality
                )
                
                # Include holidays if requested
                if (input$include_holidays) {
                  test_fit <- add_country_holidays(test_fit, country = input$holiday_country)
                }
                
                # Make future dataframe
                test_future <- make_future_dataframe(test_fit, periods = test_size, freq = "day")
                
                # Generate forecast
                test_prophet_forecast <- predict(test_fit, test_future)
                
                # Extract forecast values
                predicted <- tail(test_prophet_forecast$yhat, test_size)
              }
              
              # Calculate metrics
              performance_metrics[[current_item]] <- calculate_metrics(test_data$Volume, predicted)
            }
          }
        }
        
        # Store results in reactive values
        rv$forecast_results <- forecast_results
        rv$performance_metrics <- performance_metrics
        rv$model_objects <- model_objects
        rv$forecast_generated <- TRUE
        
        # Update other item selection inputs
        updateSelectInput(session, "results_item",
                          choices = unique(forecast_results$Item_Name),
                          selected = unique(forecast_results$Item_Name)[1])
        
        updateSelectInput(session, "diagnostics_item",
                          choices = unique(forecast_results$Item_Name),
                          selected = unique(forecast_results$Item_Name)[1])
        
        # Notify user
        showNotification(
          paste("Forecast completed for", length(items_to_forecast), "items"), 
          type = "message"
        )
        
      }, error = function(e) {
        showNotification(
          paste("Error in forecasting:", e$message), 
          type = "error"
        )
      })
    })
  })
  
  
  # ===== Data Status Indicators =====
  output$data_status_indicators <- renderUI({
    req(rv$processed_data)
    
    # Calculate stats
    missing_count <- sum(is.na(rv$processed_data$Volume))
    total_count <- nrow(rv$processed_data)
    missing_pct <- missing_count / total_count * 100
    
    # Outlier count (if available)
    outlier_count <- if (!is.null(rv$outliers)) nrow(rv$outliers) else 0
    outlier_pct <- outlier_count / total_count * 100
    
    # Create status indicators
    tagList(
      div(class = "progress-card",
          strong("Data Overview:"),
          p(
            "Records: ", total_count,
            ", Items: ", length(unique(rv$processed_data$Item_ID)),
            ", Date Range: ", format(min(rv$processed_data$Date, na.rm = TRUE), "%Y-%m-%d"), 
            " to ", format(max(rv$processed_data$Date, na.rm = TRUE), "%Y-%m-%d")
          )
      ),
      
      div(class = "progress-card",
          strong("Missing Values:"),
          div(class = "progress",
              div(class = "progress-bar",
                  id = "missing_progress_bar",
                  role = "progressbar",
                  style = if(missing_count > 0) {
                    paste0("width: ", min(missing_pct * 5, 100), "%; ",
                           "background-color: ", if(missing_pct > 10) "#dd4b39" else "#f39c12")
                  } else {
                    "width: 100%; background-color: #00a65a"
                  }
              )
          ),
          p(
            missing_count, " missing values (", round(missing_pct, 2), "%)",
            if (missing_count == 0) icon("check", class = "text-success") else NULL
          )
      ),
      
      div(class = "progress-card",
          strong("Outliers:"),
          div(class = "progress",
              div(class = "progress-bar",
                  id = "outlier_progress_bar",
                  role = "progressbar",
                  style = if(outlier_count > 0) {
                    paste0("width: ", min(outlier_pct * 10, 100), "%; ",
                           "background-color: ", if(outlier_pct > 5) "#dd4b39" else "#f39c12")
                  } else {
                    "width: 100%; background-color: #00a65a"
                  }
              )
          ),
          p(
            outlier_count, " outliers (", round(outlier_pct, 2), "%)",
            if (outlier_count == 0) icon("check", class = "text-success") else NULL
          )
      ),
      
      div(class = "progress-card",
          strong("Preprocessing Applied:"),
          div(class = "progress",
              div(class = "progress-bar bg-info",
                  id = "preprocessing_progress_bar",
                  role = "progressbar",
                  style = paste0("width: ", min(length(rv$preprocessing_steps) * 20, 100), "%")
              )
          ),
          p(
            length(rv$preprocessing_steps), " preprocessing steps applied"
          )
      )
    )
  })
  
  # ===== Item Statistics =====
  output$stats_n_obs <- renderValueBox({
    req(rv$processed_data, rv$current_item)
    
    item_data <- rv$processed_data %>%
      filter(Item_Name == rv$current_item)
    
    valueBox(
      nrow(item_data),
      "Observations",
      icon = icon("list"),
      color = "blue",
      width = 12
    )
  })
  
  output$stats_mean <- renderValueBox({
    req(rv$processed_data, rv$current_item)
    
    item_data <- rv$processed_data %>%
      filter(Item_Name == rv$current_item)
    
    valueBox(
      round(mean(item_data$Volume, na.rm = TRUE), 2),
      "Mean Volume",
      icon = icon("calculator"),
      color = "blue",
      width = 12
    )
  })
  
  output$stats_stdev <- renderValueBox({
    req(rv$processed_data, rv$current_item)
    
    item_data <- rv$processed_data %>%
      filter(Item_Name == rv$current_item)
    
    valueBox(
      round(sd(item_data$Volume, na.rm = TRUE), 2),
      "Standard Deviation",
      icon = icon("chart-line"),
      color = "blue",
      width = 12
    )
  })
  
  output$stats_missing <- renderValueBox({
    req(rv$processed_data, rv$current_item)
    
    item_data <- rv$processed_data %>%
      filter(Item_Name == rv$current_item)
    
    missing_count <- sum(is.na(item_data$Volume))
    missing_pct <- missing_count / nrow(item_data) * 100
    
    valueBox(
      paste0(missing_count, " (", round(missing_pct, 1), "%)"),
      "Missing Values",
      icon = icon("question-circle"),
      color = if(missing_count > 0) "yellow" else "green",
      width = 12
    )
  })
  
  output$stats_outliers <- renderValueBox({
    req(rv$processed_data, rv$current_item)
    
    if (is.null(rv$outliers)) {
      outlier_count <- 0
      outlier_pct <- 0
    } else {
      item_data <- rv$processed_data %>%
        filter(Item_Name == rv$current_item)
      
      outlier_data <- rv$outliers %>%
        filter(Item_Name == rv$current_item)
      
      outlier_count <- nrow(outlier_data)
      outlier_pct <- outlier_count / nrow(item_data) * 100
    }
    
    valueBox(
      paste0(outlier_count, " (", round(outlier_pct, 1), "%)"),
      "Outliers",
      icon = icon("exclamation-triangle"),
      color = if(outlier_count > 0) "orange" else "green",
      width = 12
    )
  })
  
  # ===== Apply All Preprocessing =====
  observeEvent(input$apply_preprocessing, {
    req(rv$processed_data)
    
    if (length(rv$preprocessing_steps) == 0) {
      showNotification("No preprocessing steps to apply", type = "warning")
      return()
    }
    
    showNotification("All preprocessing steps have been applied to the data", type = "message")
  })
  
  # ===== Reset Preprocessing =====
  observeEvent(input$reset_preprocessing, {
    req(rv$data)
    
    # Reset to original data
    rv$processed_data <- rv$data
    
    # Clear preprocessing steps
    rv$preprocessing_steps <- list()
    
    # Clear outliers
    rv$outliers <- NULL
    
    # Notify user
    showNotification("Data reset to original state", type = "warning")
  })
  
  # ===== Download Preprocessed Data =====
  output$download_preprocessed <- downloadHandler(
    filename = function() {
      paste0("preprocessed_data_", Sys.Date(), ".xlsx")
    },
    content = function(file) {
      req(rv$processed_data)
      
      # Prepare data for export
      export_data <- rv$processed_data
      
      # Add preprocessing info
      preprocessing_info <- data.frame(
        Step = character(),
        Details = character(),
        Timestamp = character(),
        stringsAsFactors = FALSE
      )
      
      for (step_name in names(rv$preprocessing_steps)) {
        step <- rv$preprocessing_steps[[step_name]]
        
        details <- ""
        
        if (step_name == "missing_values") {
          details <- paste("Method:", step$method)
        } else if (step_name == "duplicates") {
          details <- paste("Method:", step$method)
        } else if (step_name == "outliers") {
          details <- paste("Method:", step$method, "Threshold:", step$threshold, "Action:", step$action)
        } else if (step_name == "aggregation") {
          details <- paste("Method:", step$method, "Function:", step$agg_function)
          if (!is.null(step$custom_period)) {
            details <- paste(details, "Period:", step$custom_period)
          }
        } else if (step_name == "transformation") {
          details <- paste("Method:", step$method)
          if (!is.null(step$lambda)) {
            details <- paste(details, "Lambda:", step$lambda)
          }
        } else if (step_name == "seasonality") {
          details <- paste("Method:", step$method)
          if (!is.null(step$seasonal_type)) {
            details <- paste(details, "Type:", step$seasonal_type)
          }
          details <- paste(details, "Frequency:", step$frequency)
        }
        
        preprocessing_info <- rbind(
          preprocessing_info,
          data.frame(
            Step = step_name,
            Details = details,
            Timestamp = format(step$timestamp, "%Y-%m-%d %H:%M:%S"),
            stringsAsFactors = FALSE
          )
        )
      }
      
      # Create a list of sheets
      sheets_list <- list(
        "Data" = export_data,
        "Preprocessing_Info" = preprocessing_info
      )
      
      # Add outliers if available
      if (!is.null(rv$outliers) && nrow(rv$outliers) > 0) {
        sheets_list[["Outliers"]] <- rv$outliers
      }
      
      # Write to Excel
      write_xlsx(sheets_list, file)
    }
  )
  
  # =====================
  # Forecasting Functions
  # =====================
  
  # ===== Forecast Preview =====
  output$forecast_preview <- renderPlotly({
    req(rv$processed_data, input$forecast_item)
    
    # Filter data for selected item
    item_data <- rv$processed_data %>%
      filter(Item_Name == input$forecast_item) %>%
      arrange(Date)
    
    # Check if enough data
    if (nrow(item_data) < 5) {
      return(
        plot_ly() %>%
          layout(
            title = "Not enough data for forecast preview",
            annotations = list(
              x = 0.5,
              y = 0.5,
              text = "Need at least 5 data points for forecasting",
              showarrow = FALSE,
              font = list(size = 16)
            )
          )
      )
    }
    
    # Create time series object
    ts_data <- ts(
      item_data$Volume, 
      frequency = as.numeric(input$frequency)
    )
    
    # Prepare forecast
    horizon <- min(input$h_value, 10)  # Limit preview to 10 periods
    forecast_result <- NULL
    
    tryCatch({
      if (input$method == "ARIMA") {
        if (input$auto_arima) {
          fit <- auto.arima(ts_data)
        } else {
          # Use manual parameters
          if (input$seasonal_arima) {
            fit <- Arima(ts_data, 
                         order = c(input$p_value, input$d_value, input$q_value),
                         seasonal = list(order = c(input$P_value, input$D_value, input$Q_value), 
                                         period = input$S_value))
          } else {
            fit <- Arima(ts_data, 
                         order = c(input$p_value, input$d_value, input$q_value))
          }
        }
        
        forecast_result <- forecast(fit, h = horizon)
      } else if (input$method == "Exponential Smoothing") {
        if (input$auto_ets) {
          fit <- ets(ts_data)
        } else {
          # Use manual parameters
          model <- input$ets_model
          fit <- ets(ts_data, model = model, 
                     alpha = input$alpha, 
                     beta = input$beta, 
                     gamma = input$gamma)
        }
        
        forecast_result <- forecast(fit, h = horizon)
      } else if (input$method == "Prophet") {
        # Prepare data for Prophet
        prophet_data <- data.frame(
          ds = item_data$Date,
          y = item_data$Volume
        )
        
        # Configure Prophet model
        fit <- prophet(
          prophet_data,
          changepoint.prior.scale = input$changepoint_prior,
          seasonality.prior.scale = input$seasonality_prior,
          yearly.seasonality = input$yearly_seasonality,
          weekly.seasonality = input$weekly_seasonality,
          daily.seasonality = input$daily_seasonality
        )
        
        # Include holidays if requested
        if (input$include_holidays) {
          fit <- add_country_holidays(fit, country = input$holiday_country)
        }
        
        # Make future dataframe
        future <- make_future_dataframe(fit, periods = horizon, freq = "day")
        
        # Generate forecast
        prophet_forecast <- predict(fit, future)
        
        # Format output to match other methods
        forecast_dates <- tail(prophet_forecast$ds, horizon)
        forecast_values <- tail(prophet_forecast$yhat, horizon)
        lower_bound <- tail(prophet_forecast$yhat_lower, horizon)
        upper_bound <- tail(prophet_forecast$yhat_upper, horizon)
        
        # Manually create a structure similar to forecast objects
        forecast_result <- list(
          mean = forecast_values,
          lower = cbind(lower_bound),
          upper = cbind(upper_bound),
          x = ts_data,
          method = "Prophet"
        )
        
        class(forecast_result) <- "forecast"
      }
      
      # Create plot
      if (!is.null(forecast_result)) {
        # Determine date range for forecast
        last_date <- max(item_data$Date)
        forecast_dates <- seq.Date(
          from = last_date + days(1),
          by = "day",
          length.out = horizon
        )
        
        # Create base plot with historical data
        p <- plot_ly() %>%
          add_trace(
            x = item_data$Date,
            y = item_data$Volume,
            type = 'scatter',
            mode = 'lines',
            line = list(color = '#3c8dbc', width = 2),
            name = 'Historical'
          )
        
        # Add forecast
        p <- p %>%
          add_trace(
            x = forecast_dates,
            y = forecast_result$mean,
            type = 'scatter',
            mode = 'lines',
            line = list(color = '#00a65a', width = 2, dash = 'dash'),
            name = 'Forecast'
          )
        
        # Add prediction intervals if requested
        if (input$use_prediction_intervals) {
          # Determine which interval to use (80% or 95%)
          interval_idx <- if (input$prediction_interval <= 80) 1 else 2
          
          # For Prophet, we already have the bounds
          if (input$method == "Prophet") {
            lower_bounds <- forecast_result$lower
            upper_bounds <- forecast_result$upper
          } else {
            lower_bounds <- forecast_result$lower[, interval_idx]
            upper_bounds <- forecast_result$upper[, interval_idx]
          }
          
          # Add interval as a shaded area
          p <- p %>%
            add_trace(
              x = c(forecast_dates, rev(forecast_dates)),
              y = c(lower_bounds, rev(upper_bounds)),
              type = 'scatter',
              mode = 'lines',
              fill = 'toself',
              fillcolor = 'rgba(0, 166, 90, 0.2)',
              line = list(color = 'transparent'),
              showlegend = FALSE,
              name = paste0(input$prediction_interval, "% Interval")
            )
        }
        
        # Finalize layout
        p <- p %>%
          layout(
            title = paste("Forecast Preview for", input$forecast_item),
            xaxis = list(title = "Date"),
            yaxis = list(title = "Volume"),
            hovermode = "closest",
            showlegend = TRUE
          )
        
        return(p)
      } else {
        return(
          plot_ly() %>%
            layout(
              title = "No forecast generated",
              annotations = list(
                x = 0.5,
                y = 0.5,
                text = "Unable to generate forecast preview",
                showarrow = FALSE,
                font = list(size = 16)
              )
            )
        )
      }
    }, error = function(e) {
      return(
        plot_ly() %>%
          layout(
            title = "Error in forecast preview",
            annotations = list(
              x = 0.5,
              y = 0.5,
              text = paste("Error:", e$message),
              showarrow = FALSE,
              font = list(size = 16)
            )
          )
      )
    })
  })
  
  # ===== Update Preview =====
  observeEvent(input$update_preview, {
    # Just trigger the preview to refresh
    showNotification("Updating forecast preview...", type = "message")
  })
  
  # ===== Helper function to calculate performance metrics =====
  calculate_metrics <- function(actual, predicted) {
    # Ensure vectors are of same length
    min_length <- min(length(actual), length(predicted))
    actual <- actual[1:min_length]
    predicted <- predicted[1:min_length]
    
    # Remove any NA values
    valid_idx <- !is.na(actual) & !is.na(predicted)
    if (sum(valid_idx) == 0) {
      return(list(MAE = NA, RMSE = NA, MAPE = NA))
    }
    
    actual <- actual[valid_idx]
    predicted <- predicted[valid_idx]
    
    # Calculate metrics
    mae <- mean(abs(actual - predicted))
    rmse <- sqrt(mean((actual - predicted)^2))
    
    # Handle zero values in actual for MAPE calculation
    if (any(actual == 0)) {
      # Modified MAPE to handle zeros
      non_zero <- actual != 0
      if (sum(non_zero) > 0) {
        mape <- mean(abs((actual[non_zero] - predicted[non_zero]) / actual[non_zero])) * 100
      } else {
        mape <- NA
      }
    } else {
      mape <- mean(abs((actual - predicted) / actual)) * 100
    }
    
    return(list(
      MAE = round(mae, 2),
      RMSE = round(rmse, 2),
      MAPE = round(mape, 2)
    ))
  }
  
  # ===== Run Forecast =====
  observeEvent(input$go, {
    req(rv$processed_data)
    
    withProgress(message = 'Running forecasts...', value = 0, {
      
      tryCatch({
        # Determine which items to forecast
        if (input$forecast_all_items || input$batch_forecast) {
          items_to_forecast <- unique(rv$processed_data$Item_Name)
        } else {
          items_to_forecast <- input$forecast_item
        }
        
        # Initialize results structures
        forecast_results <- data.frame()
        performance_metrics <- list()
        model_objects <- list()
        
        # Set number of steps based on progress bar
        total_steps <- length(items_to_forecast)
        step_size <- 1 / total_steps
        
        # Loop through each item
        for (i in 1:total_steps) {
          # Update progress
          incProgress(step_size, detail = paste("Forecasting item", i, "of", total_steps))
          
          current_item <- items_to_forecast[i]
          
          # Filter data for current item
          item_data <- rv$processed_data %>%
            filter(Item_Name == current_item) %>%
            arrange(Date)
          
          # Skip if not enough data
          if (nrow(item_data) < 5) {
            showNotification(paste("Skipping", current_item, "- not enough data"), type = "warning")
            next
          }
          
          # Create time series object
          ts_data <- ts(
            item_data$Volume, 
            frequency = as.numeric(input$frequency)
          )
          
          # Set forecast horizon
          horizon <- input$h_value
          
          # Generate forecast based on selected method
          forecast_result <- NULL
          
          if (input$method == "ARIMA") {
            if (input$auto_arima) {
              fit <- auto.arima(ts_data)
            } else {
              # Use manual parameters
              if (input$seasonal_arima) {
                fit <- Arima(ts_data, 
                             order = c(input$p_value, input$d_value, input$q_value),
                             seasonal = list(order = c(input$P_value, input$D_value, input$Q_value), 
                                             period = input$S_value))
              } else {
                fit <- Arima(ts_data, 
                             order = c(input$p_value, input$d_value, input$q_value))
              }
            }
            
            forecast_result <- forecast(fit, h = horizon)
            model_objects[[current_item]] <- fit
          } else if (input$method == "Exponential Smoothing") {
            if (input$auto_ets) {
              fit <- ets(ts_data)
            } else {
              # Use manual parameters
              model <- input$ets_model
              fit <- ets(ts_data, model = model, 
                         alpha = input$alpha, 
                         beta = input$beta, 
                         gamma = input$gamma)
            }
            
            forecast_result <- forecast(fit, h = horizon)
            model_objects[[current_item]] <- fit
          } else if (input$method == "Prophet") {
            # Prepare data for Prophet
            prophet_data <- data.frame(
              ds = item_data$Date,
              y = item_data$Volume
            )
            
            # Configure Prophet model
            fit <- prophet(
              prophet_data,
              changepoint.prior.scale = input$changepoint_prior,
              seasonality.prior.scale = input$seasonality_prior,
              yearly.seasonality = input$yearly_seasonality,
              weekly.seasonality = input$weekly_seasonality,
              daily.seasonality = input$daily_seasonality
            )
            
            # Include holidays if requested
            if (input$include_holidays) {
              fit <- add_country_holidays(fit, country = input$holiday_country)
            }
            
            # Make future dataframe
            future <- make_future_dataframe(fit, periods = horizon, freq = "day")
            
            # Generate forecast
            prophet_forecast <- predict(fit, future)
            
            # Store model
            model_objects[[current_item]] <- list(
              model = fit,
              forecast = prophet_forecast
            )
            
            # Extract forecast values
            forecast_dates <- tail(prophet_forecast$ds, horizon)
            forecast_values <- tail(prophet_forecast$yhat, horizon)
            
            # Calculate prediction intervals
            lower_bound <- tail(prophet_forecast$yhat_lower, horizon)
            upper_bound <- tail(prophet_forecast$yhat_upper, horizon)
            
            # Create a data frame for results
            prophet_results <- data.frame(
              Date = forecast_dates,
              Forecast = forecast_values,
              Lower = lower_bound,
              Upper = upper_bound
            )
            
            # Format as a forecast object for consistent processing
            forecast_result <- list(
              mean = forecast_values,
              lower = cbind(lower_bound),
              upper = cbind(upper_bound),
              x = ts_data,
              method = "Prophet"
            )
            
            class(forecast_result) <- "forecast"
          }
          
          # Process forecast results
          if (!is.null(forecast_result)) {
            # Determine date range for forecast
            last_date <- max(item_data$Date)
            forecast_dates <- seq.Date(
              from = last_date + days(1),
              by = "day",
              length.out = horizon
            )
            
            # Create data frame for this item's forecast
            item_forecast <- data.frame(
              Date = forecast_dates,
              Forecast = as.numeric(forecast_result$mean),
              Item_ID = unique(item_data$Item_ID),
              Item_Name = current_item
            )
            
            # Add prediction intervals
            if (input$use_prediction_intervals) {
              interval_idx <- if (input$prediction_interval <= 80) 1 else 2
              
              if (input$method == "Prophet") {
                item_forecast$Lower <- as.numeric(forecast_result$lower)
                item_forecast$Upper <- as.numeric(forecast_result$upper)
              } else {
                item_forecast$Lower <- as.numeric(forecast_result$lower[, interval_idx])
                item_forecast$Upper <- as.numeric(forecast_result$upper[, interval_idx])
              }
            }
            
            # Append to results
            forecast_results <- rbind(forecast_results, item_forecast)
            
            # Calculate performance metrics if possible
            if (nrow(item_data) > horizon) {
              # Use the last part of the historical data as a test set
              test_size <- min(horizon, floor(nrow(item_data) / 3))
              train_data <- head(item_data, -test_size)
              test_data <- tail(item_data, test_size)
              
              # Re-fit and forecast
              if (input$method == "ARIMA") {
                if (input$auto_arima) {
                  test_fit <- auto.arima(ts(train_data$Volume, frequency = as.numeric(input$frequency)))
                } else {
                  if (input$seasonal_arima) {
                    test_fit <- Arima(ts(train_data$Volume, frequency = as.numeric(input$frequency)),
                                      order = c(input$p_value, input$d_value, input$q_value),
                                      seasonal = list(order = c(input$P_value, input$D_value, input$Q_value),
                                                      period = input$S_value))
                  } else {
                    test_fit <- Arima(ts(train_data$Volume, frequency = as.numeric(input$frequency)),
                                      order = c(input$p_value, input$d_value, input$q_value))
                  }
                }
                
                test_forecast <- forecast(test_fit, h = test_size)
                predicted <- as.numeric(test_forecast$mean)
              } else if (input$method == "Exponential Smoothing") {
                if (input$auto_ets) {
                  test_fit <- ets(ts(train_data$Volume, frequency = as.numeric(input$frequency)))
                } else {
                  test_fit <- ets(ts(train_data$Volume, frequency = as.numeric(input$frequency)),
                                  model = input$ets_model,
                                  alpha = input$alpha,
                                  beta = input$beta,
                                  gamma = input$gamma)
                }
                
                test_forecast <- forecast(test_fit, h = test_size)
                predicted <- as.numeric(test_forecast$mean)
              } else if (input$method == "Prophet") {
                # Prepare train data for Prophet
                prophet_train <- data.frame(
                  ds = train_data$Date,
                  y = train_data$Volume
                )
                
                # Configure Prophet model
                test_fit <- prophet(
                  prophet_train,
                  changepoint.prior.scale = input$changepoint_prior,
                  seasonality.prior.scale = input$seasonality_prior,
                  yearly.seasonality = input$yearly_seasonality,
                  weekly.seasonality = input$weekly_seasonality,
                  daily.seasonality = input$daily_seasonality
                )
                
                # Include holidays if requested
                if (input$include_holidays) {
                  test_fit <- add_country_holidays(test_fit, country = input$holiday_country)
                }
                
                # Make future dataframe
                test_future <- make_future_dataframe(test_fit, periods = test_size, freq = "day")
                
                # Generate forecast
                test_prophet_forecast <- predict(test_fit, test_future)
                
                # Extract forecast values
                predicted <- tail(test_prophet_forecast$yhat, test_size)
              }
              
              # Calculate metrics
              performance_metrics[[current_item]] <- calculate_metrics(test_data$Volume, predicted)
            }
          }
        }
        
        # Store results in reactive values
        rv$forecast_results <- forecast_results
        rv$performance_metrics <- performance_metrics
        rv$model_objects <- model_objects
        rv$forecast_generated <- TRUE
        
        # Update other item selection inputs
        updateSelectInput(session, "results_item",
                          choices = unique(forecast_results$Item_Name),
                          selected = unique(forecast_results$Item_Name)[1])
        
        updateSelectInput(session, "diagnostics_item",
                          choices = unique(forecast_results$Item_Name),
                          selected = unique(forecast_results$Item_Name)[1])
        
        # Notify user
        showNotification(
          paste("Forecast completed for", length(items_to_forecast), "items"), 
          type = "message"
        )
        
      }, error = function(e) {
        showNotification(
          paste("Error in forecasting:", e$message), 
          type = "error"
        )
      })
    })
  })
  
  # =====================
  # Diagnostics Tab Functions
  # =====================
  
  # ===== Residual Plot =====
  output$residual_plot <- renderPlotly({
    req(rv$model_objects, input$diagnostics_item)
    
    # Get model object for selected item
    model <- rv$model_objects[[input$diagnostics_item]]
    
    if (is.null(model)) {
      return(
        plot_ly() %>%
          layout(
            title = "No model available",
            annotations = list(
              x = 0.5,
              y = 0.5,
              text = "No model found for the selected item",
              showarrow = FALSE,
              font = list(size = 16)
            )
          )
      )
    }
    
    # Extract residuals based on model type
    if (input$method == "ARIMA" || input$method == "Exponential Smoothing") {
      residuals_ts <- residuals(model)
      residuals_values <- as.numeric(residuals_ts)
      
      # Get dates corresponding to residuals
      item_data <- rv$processed_data %>%
        filter(Item_Name == input$diagnostics_item) %>%
        arrange(Date)
      
      dates <- item_data$Date[1:length(residuals_values)]
      
      # Create data frame for plotting
      residuals_df <- data.frame(
        Date = dates,
        Residual = residuals_values
      )
    } else if (input$method == "Prophet") {
      # For Prophet, get the residuals from the model's dataframe
      if ("model" %in% names(model) && !is.null(model$forecast)) {
        prophet_forecast <- model$forecast
        
        # Match with historical data to calculate residuals
        item_data <- rv$processed_data %>%
          filter(Item_Name == input$diagnostics_item) %>%
          arrange(Date)
        
        # Find common dates between forecast and actual
        common_dates <- intersect(as.Date(prophet_forecast$ds), item_data$Date)
        
        if (length(common_dates) > 0) {
          forecast_subset <- prophet_forecast %>%
            filter(as.Date(ds) %in% common_dates) %>%
            select(ds, yhat)
          
          actual_subset <- item_data %>%
            filter(Date %in% common_dates) %>%
            select(Date, Volume)
          
          # Join and calculate residuals
          residuals_df <- inner_join(
            forecast_subset %>% mutate(ds = as.Date(ds)),
            actual_subset,
            by = c("ds" = "Date")
          ) %>%
            mutate(Residual = Volume - yhat) %>%
            select(Date = ds, Residual)
        } else {
          # No common dates, return empty plot
          return(
            plot_ly() %>%
              layout(
                title = "Cannot calculate residuals",
                annotations = list(
                  x = 0.5,
                  y = 0.5,
                  text = "No matching dates found to calculate residuals",
                  showarrow = FALSE,
                  font = list(size = 16)
                )
              )
          )
        }
      } else {
        # No forecast available
        return(
          plot_ly() %>%
            layout(
              title = "Residuals not available",
              annotations = list(
                x = 0.5,
                y = 0.5,
                text = "Prophet model forecast details not found",
                showarrow = FALSE,
                font = list(size = 16)
              )
            )
        )
      }
    }
    
    # Create different plot types based on selection
    if (input$residual_plot_type == "Time Series") {
      # Time series plot of residuals
      p <- plot_ly(
        data = residuals_df,
        x = ~Date,
        y = ~Residual,
        type = 'scatter',
        mode = 'lines+markers',
        marker = list(size = 3, color = '#3c8dbc'),
        line = list(width = 1, color = '#3c8dbc')
      ) %>%
        add_trace(
          y = rep(0, nrow(residuals_df)),
          type = 'scatter',
          mode = 'lines',
          line = list(color = 'gray', width = 1, dash = 'dash'),
          showlegend = FALSE
        ) %>%
        layout(
          title = "Residuals Over Time",
          xaxis = list(title = "Date"),
          yaxis = list(title = "Residual"),
          showlegend = FALSE
        )
      
    } else if (input$residual_plot_type == "Histogram") {
      # Histogram of residuals
      p <- plot_ly(
        x = residuals_df$Residual,
        type = 'histogram',
        nbinsx = 30,
        marker = list(color = '#3c8dbc')
      ) %>%
        layout(
          title = "Distribution of Residuals",
          xaxis = list(title = "Residual"),
          yaxis = list(title = "Frequency"),
          showlegend = FALSE
        )
      
    } else if (input$residual_plot_type == "QQ Plot") {
      # QQ plot (quantile-quantile plot)
      qq <- qqnorm(residuals_df$Residual, plot.it = FALSE)
      qq_df <- data.frame(x = qq$x, y = qq$y)
      
      # Fit a line
      line_fit <- lm(y ~ x, data = qq_df)
      line_pred <- predict(line_fit, newdata = data.frame(x = range(qq_df$x)))
      line_df <- data.frame(
        x = range(qq_df$x),
        y = line_pred
      )
      
      p <- plot_ly() %>%
        add_trace(
          data = qq_df,
          x = ~x,
          y = ~y,
          type = 'scatter',
          mode = 'markers',
          marker = list(size = 5, color = '#3c8dbc'),
          name = 'Quantiles'
        ) %>%
        add_trace(
          data = line_df,
          x = ~x,
          y = ~y,
          type = 'scatter',
          mode = 'lines',
          line = list(color = '#f39c12', width = 2),
          name = 'Reference Line'
        ) %>%
        layout(
          title = "Normal Q-Q Plot of Residuals",
          xaxis = list(title = "Theoretical Quantiles"),
          yaxis = list(title = "Sample Quantiles"),
          showlegend = TRUE
        )
      
    } else if (input$residual_plot_type == "ACF") {
      # Autocorrelation function plot
      acf_values <- acf(residuals_df$Residual, plot = FALSE)
      
      acf_df <- data.frame(
        Lag = acf_values$lag,
        ACF = acf_values$acf
      )
      
      # Calculate significance bounds
      n <- length(residuals_df$Residual)
      significance_level <- 0.95
      ci <- qnorm((1 + significance_level) / 2) / sqrt(n)
      
      p <- plot_ly() %>%
        add_trace(
          data = acf_df,
          x = ~Lag,
          y = ~ACF,
          type = 'bar',
          marker = list(color = '#3c8dbc'),
          name = 'ACF'
        ) %>%
        add_trace(
          x = c(min(acf_df$Lag) - 1, max(acf_df$Lag) + 1),
          y = c(ci, ci),
          type = 'scatter',
          mode = 'lines',
          line = list(color = '#f39c12', width = 2, dash = 'dash'),
          name = paste0(significance_level * 100, "% Confidence Bound")
        ) %>%
        add_trace(
          x = c(min(acf_df$Lag) - 1, max(acf_df$Lag) + 1),
          y = c(-ci, -ci),
          type = 'scatter',
          mode = 'lines',
          line = list(color = '#f39c12', width = 2, dash = 'dash'),
          showlegend = FALSE
        ) %>%
        layout(
          title = "Autocorrelation of Residuals",
          xaxis = list(title = "Lag"),
          yaxis = list(title = "Autocorrelation"),
          showlegend = TRUE
        )
    }
    
    return(p)
  })
  
  # ===== Residual Statistics =====
  output$residual_stats <- renderPrint({
    req(rv$model_objects, input$diagnostics_item)
    
    # Get model object for selected item
    model <- rv$model_objects[[input$diagnostics_item]]
    
    if (is.null(model)) {
      cat("No model available for", input$diagnostics_item)
      return()
    }
    
    # Extract residuals based on model type
    residuals_values <- NULL
    
    if (input$method == "ARIMA" || input$method == "Exponential Smoothing") {
      residuals_values <- as.numeric(residuals(model))
    } else if (input$method == "Prophet") {
      # For Prophet, calculate residuals from the forecast
      if ("model" %in% names(model) && !is.null(model$forecast)) {
        prophet_forecast <- model$forecast
        
        # Match with historical data
        item_data <- rv$processed_data %>%
          filter(Item_Name == input$diagnostics_item) %>%
          arrange(Date)
        
        # Find common dates
        common_dates <- intersect(as.Date(prophet_forecast$ds), item_data$Date)
        
        if (length(common_dates) > 0) {
          forecast_subset <- prophet_forecast %>%
            filter(as.Date(ds) %in% common_dates) %>%
            select(ds, yhat)
          
          actual_subset <- item_data %>%
            filter(Date %in% common_dates) %>%
            select(Date, Volume)
          
          # Calculate residuals
          residuals_df <- inner_join(
            forecast_subset %>% mutate(ds = as.Date(ds)),
            actual_subset,
            by = c("ds" = "Date")
          ) %>%
            mutate(Residual = Volume - yhat)
          
          residuals_values <- residuals_df$Residual
        } else {
          cat("Cannot calculate residuals - no matching dates found")
          return()
        }
      } else {
        cat("Residuals not available for Prophet model")
        return()
      }
    }
    
    if (is.null(residuals_values) || length(residuals_values) == 0) {
      cat("No residuals available")
      return()
    }
    
    # Calculate basic statistics
    cat("Residual Statistics:\n\n")
    cat("Number of observations:", length(residuals_values), "\n")
    cat("Mean:", round(mean(residuals_values, na.rm = TRUE), 4), "\n")
    cat("Standard deviation:", round(sd(residuals_values, na.rm = TRUE), 4), "\n")
    cat("Minimum:", round(min(residuals_values, na.rm = TRUE), 4), "\n")
    cat("Maximum:", round(max(residuals_values, na.rm = TRUE), 4), "\n")
    
    # Calculate quantiles
    quantiles <- quantile(residuals_values, probs = c(0.25, 0.5, 0.75), na.rm = TRUE)
    cat("\nQuantiles:\n")
    cat("25%:", round(quantiles[1], 4), "\n")
    cat("50% (Median):", round(quantiles[2], 4), "\n")
    cat("75%:", round(quantiles[3], 4), "\n")
    
    # Test for normality
    shapiro_test <- shapiro.test(residuals_values)
    cat("\nShapiro-Wilk Normality Test:\n")
    cat("W:", round(shapiro_test$statistic, 4), "\n")
    cat("p-value:", round(shapiro_test$p.value, 4), "\n")
    cat("Interpretation: ", ifelse(shapiro_test$p.value > 0.05, 
                                   "Residuals appear to be normally distributed",
                                   "Residuals may not be normally distributed"), "\n")
  })
  
  # ===== Residual Tests =====
  output$residual_tests <- renderPrint({
    req(rv$model_objects, input$diagnostics_item)
    
    # Get model object for selected item
    model <- rv$model_objects[[input$diagnostics_item]]
    
    if (is.null(model)) {
      cat("No model available for", input$diagnostics_item)
      return()
    }
    
    # Extract residuals based on model type
    residuals_values <- NULL
    
    if (input$method == "ARIMA" || input$method == "Exponential Smoothing") {
      residuals_values <- as.numeric(residuals(model))
    } else if (input$method == "Prophet") {
      # Calculate residuals for Prophet as before
      if ("model" %in% names(model) && !is.null(model$forecast)) {
        prophet_forecast <- model$forecast
        item_data <- rv$processed_data %>%
          filter(Item_Name == input$diagnostics_item) %>%
          arrange(Date)
        
        common_dates <- intersect(as.Date(prophet_forecast$ds), item_data$Date)
        
        if (length(common_dates) > 0) {
          forecast_subset <- prophet_forecast %>%
            filter(as.Date(ds) %in% common_dates) %>%
            select(ds, yhat)
          
          actual_subset <- item_data %>%
            filter(Date %in% common_dates) %>%
            select(Date, Volume)
          
          residuals_df <- inner_join(
            forecast_subset %>% mutate(ds = as.Date(ds)),
            actual_subset,
            by = c("ds" = "Date")
          ) %>%
            mutate(Residual = Volume - yhat)
          
          residuals_values <- residuals_df$Residual
        } else {
          cat("Cannot calculate residuals - no matching dates found")
          return()
        }
      } else {
        cat("Residuals not available for Prophet model")
        return()
      }
    }
    
    if (is.null(residuals_values) || length(residuals_values) == 0) {
      cat("No residuals available")
      return()
    }
    
    # Run randomness tests
    cat("Tests for Randomness in Residuals:\n\n")
    
    # Ljung-Box test
    lb_test <- Box.test(residuals_values, lag = min(10, length(residuals_values) - 1), type = "Ljung-Box")
    cat("Ljung-Box Test (for autocorrelation):\n")
    cat("Q statistic:", round(lb_test$statistic, 4), "\n")
    cat("p-value:", round(lb_test$p.value, 4), "\n")
    cat("Interpretation: ", ifelse(lb_test$p.value > 0.05, 
                                   "No significant autocorrelation detected (good)",
                                   "Significant autocorrelation detected (problematic)"), "\n\n")
    
    # Runs test for randomness
    tryCatch({
      runs_test <- tseries::runs.test(residuals_values)
      cat("Runs Test (for randomness):\n")
      cat("Statistic:", round(runs_test$statistic, 4), "\n")
      cat("p-value:", round(runs_test$p.value, 4), "\n")
      cat("Interpretation: ", ifelse(runs_test$p.value > 0.05, 
                                     "Residuals appear random (good)",
                                     "Residuals may not be random (problematic)"), "\n\n")
    }, error = function(e) {
      cat("Runs Test: Could not be performed due to an error\n\n")
    })
    
    # Test for homoscedasticity (constant variance)
    tryCatch({
      # Create a simple model of residuals vs. fitted values
      if (input$method == "ARIMA" || input$method == "Exponential Smoothing") {
        fitted_values <- as.numeric(fitted(model))
      } else {
        fitted_values <- forecast_subset$yhat
      }
      
      # Limit to common length
      min_length <- min(length(residuals_values), length(fitted_values))
      residuals_values <- residuals_values[1:min_length]
      fitted_values <- fitted_values[1:min_length]
      
      # Use Breusch-Pagan test
      bp_test <- lmtest::bptest(lm(residuals_values ~ fitted_values))
      cat("Breusch-Pagan Test (for heteroscedasticity):\n")
      cat("BP statistic:", round(bp_test$statistic, 4), "\n")
      cat("p-value:", round(bp_test$p.value, 4), "\n")
      cat("Interpretation: ", ifelse(bp_test$p.value > 0.05, 
                                     "Residuals show constant variance (good)",
                                     "Residuals show non-constant variance (problematic)"), "\n")
    }, error = function(e) {
      cat("Heteroscedasticity Test: Could not be performed due to an error\n")
    })
  })
  
  # ===== Model Parameters =====
  output$model_parameters <- renderPrint({
    req(rv$model_objects, input$diagnostics_item)
    
    # Get model object for selected item
    model <- rv$model_objects[[input$diagnostics_item]]
    
    if (is.null(model)) {
      cat("No model available for", input$diagnostics_item)
      return()
    }
    
    cat("Model Parameters for", input$diagnostics_item, "\n\n")
    
    if (input$method == "ARIMA") {
      # Print ARIMA model details
      cat("ARIMA Model Type:", paste0("ARIMA", arimaorder(model)), "\n\n")
      
      if (!is.null(model$coef)) {
        cat("Coefficients:\n")
        coef_table <- data.frame(
          Estimate = model$coef,
          StdError = sqrt(diag(model$var.coef)),
          row.names = names(model$coef)
        )
        
        # Calculate t-values and p-values
        coef_table$t_value <- coef_table$Estimate / coef_table$StdError
        coef_table$p_value <- 2 * pt(abs(coef_table$t_value), 
                                     df = length(model$residuals) - length(model$coef), 
                                     lower.tail = FALSE)
        
        # Add significance stars
        coef_table$significance <- ""
        coef_table$significance[coef_table$p_value < 0.05] <- "*"
        coef_table$significance[coef_table$p_value < 0.01] <- "**"
        coef_table$significance[coef_table$p_value < 0.001] <- "***"
        
        print(round(coef_table, 4))
        cat("\nSignificance codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n")
      } else {
        cat("No coefficients available for this model\n\n")
      }
      
      cat("Information Criteria:\n")
      cat("AIC:", round(model$aic, 2), "\n")
      cat("BIC:", round(BIC(model), 2), "\n")
      cat("Log Likelihood:", round(model$loglik, 2), "\n\n")
      
      cat("Residual Variance:", round(model$sigma2, 4), "\n")
      
    } else if (input$method == "Exponential Smoothing") {
      # Print ETS model details
      cat("ETS Model:", model$method, "\n\n")
      
      cat("Components:\n")
      cat("Error:", model$components[1], "\n")
      cat("Trend:", model$components[2], "\n")
      cat("Seasonal:", model$components[3], "\n\n")
      
      cat("Smoothing Parameters:\n")
      for (param_name in names(model$par)) {
        cat(param_name, ":", round(model$par[param_name], 4), "\n")
      }
      
      cat("\nInitial States:\n")
      if (!is.null(model$initstate)) {
        for (i in 1:length(model$initstate)) {
          cat("l[", i, "] =", round(model$initstate[i], 4), "\n")
        }
      }
      
      cat("\nInformation Criteria:\n")
      cat("AIC:", round(model$aic, 2), "\n")
      cat("BIC:", round(model$bic, 2), "\n")
      cat("AICc:", round(model$aicc, 2), "\n")
      cat("Log Likelihood:", round(model$loglik, 2), "\n")
      
    } else if (input$method == "Prophet") {
      if ("model" %in% names(model)) {
        prophet_model <- model$model
        
        cat("Prophet Model Configuration:\n\n")
        
        cat("Growth:", prophet_model$growth, "\n")
        cat("Changepoint Prior Scale:", prophet_model$changepoint.prior.scale, "\n")
        cat("Seasonality Prior Scale:", prophet_model$seasonality.prior.scale, "\n")
        
        # List seasonality components
        cat("\nSeasonality Components:\n")
        if (prophet_model$yearly.seasonality) {
          cat("- Yearly Seasonality\n")
          if (!is.null(prophet_model$seasonalities$yearly)) {
            cat("  Period:", prophet_model$seasonalities$yearly$period, "days\n")
            cat("  Fourier Order:", prophet_model$seasonalities$yearly$fourier.order, "\n")
            cat("  Mode:", prophet_model$seasonalities$yearly$mode, "\n")
          }
        }
        
        if (prophet_model$weekly.seasonality) {
          cat("- Weekly Seasonality\n")
          if (!is.null(prophet_model$seasonalities$weekly)) {
            cat("  Period:", prophet_model$seasonalities$weekly$period, "days\n")
            cat("  Fourier Order:", prophet_model$seasonalities$weekly$fourier.order, "\n")
            cat("  Mode:", prophet_model$seasonalities$weekly$mode, "\n")
          }
        }
        
        if (prophet_model$daily.seasonality) {
          cat("- Daily Seasonality\n")
          if (!is.null(prophet_model$seasonalities$daily)) {
            cat("  Period:", prophet_model$seasonalities$daily$period, "days\n")
            cat("  Fourier Order:", prophet_model$seasonalities$daily$fourier.order, "\n")
            cat("  Mode:", prophet_model$seasonalities$daily$mode, "\n")
          }
        }
        
        # List holidays if included
        if (!is.null(prophet_model$holidays)) {
          cat("\nHolidays:\n")
          cat("- Country:", prophet_model$country_holidays, "\n")
          cat("- Prior Scale:", prophet_model$holidays.prior.scale, "\n")
        }
        
        # Component statistics
        if (!is.null(model$forecast)) {
          forecast_df <- model$forecast
          
          cat("\nComponent Statistics:\n")
          
          # Calculate trend contribution
          trend_mean <- mean(forecast_df$trend, na.rm = TRUE)
          trend_std <- sd(forecast_df$trend, na.rm = TRUE)
          trend_range <- max(forecast_df$trend, na.rm = TRUE) - min(forecast_df$trend, na.rm = TRUE)
          
          cat("\nTrend Component:\n")
          cat("- Mean:", round(trend_mean, 2), "\n")
          cat("- Std Dev:", round(trend_std, 2), "\n")
          cat("- Range:", round(trend_range, 2), "\n")
          
          # If yearly seasonality is present
          if ("yearly" %in% colnames(forecast_df)) {
            yearly_mean <- mean(forecast_df$yearly, na.rm = TRUE)
            yearly_std <- sd(forecast_df$yearly, na.rm = TRUE)
            yearly_range <- max(forecast_df$yearly, na.rm = TRUE) - min(forecast_df$yearly, na.rm = TRUE)
            
            cat("\nYearly Seasonality Component:\n")
            cat("- Mean:", round(yearly_mean, 2), "\n")
            cat("- Std Dev:", round(yearly_std, 2), "\n")
            cat("- Range:", round(yearly_range, 2), "\n")
            cat("- Relative Impact:", round(yearly_range / trend_range * 100, 2), "%\n")
          }
          
          # If weekly seasonality is present
          if ("weekly" %in% colnames(forecast_df)) {
            weekly_mean <- mean(forecast_df$weekly, na.rm = TRUE)
            weekly_std <- sd(forecast_df$weekly, na.rm = TRUE)
            weekly_range <- max(forecast_df$weekly, na.rm = TRUE) - min(forecast_df$weekly, na.rm = TRUE)
            
            cat("\nWeekly Seasonality Component:\n")
            cat("- Mean:", round(weekly_mean, 2), "\n")
            cat("- Std Dev:", round(weekly_std, 2), "\n")
            cat("- Range:", round(weekly_range, 2), "\n")
            cat("- Relative Impact:", round(weekly_range / trend_range * 100, 2), "%\n")
          }
        }
      } else {
        cat("Prophet model details not available\n")
      }
    }
  })
  
  # ===== Parameter Stability =====
  output$parameter_stability <- renderPlotly({
    req(rv$model_objects, input$diagnostics_item)
    
    # Get model object for selected item
    model <- rv$model_objects[[input$diagnostics_item]]
    
    if (is.null(model)) {
      return(
        plot_ly() %>%
          layout(
            title = "No model available",
            annotations = list(
              x = 0.5,
              y = 0.5,
              text = "No model found for the selected item",
              showarrow = FALSE,
              font = list(size = 16)
            )
          )
      )
    }
    
    # Parameter stability analysis depends on the model type
    if (input$method == "ARIMA") {
      # Get data for item
      item_data <- rv$processed_data %>%
        filter(Item_Name == input$diagnostics_item) %>%
        arrange(Date)
      
      # Create time series
      ts_data <- ts(item_data$Volume, frequency = as.numeric(input$frequency))
      
      # For ARIMA models, we'll fit the same order model on different windows
      arima_order <- arimaorder(model)
      
      # Create a series of windows (e.g., growing windows)
      num_windows <- 10
      min_window_size <- max(30, length(ts_data) * 0.3) # At least 30 points or 30% of data
      
      if (length(ts_data) <= min_window_size) {
        return(
          plot_ly() %>%
            layout(
              title = "Insufficient data for parameter stability analysis",
              annotations = list(
                x = 0.5,
                y = 0.5,
                text = "Need more data points to analyze parameter stability",
                showarrow = FALSE,
                font = list(size = 16)
              )
            )
        )
      }
      
      window_ends <- floor(seq(min_window_size, length(ts_data), length.out = num_windows))
      
      # Prepare result storage
      param_results <- list()
      
      # Fit model on each window
      for (i in 1:length(window_ends)) {
        window_data <- ts_data[1:window_ends[i]]
        
        tryCatch({
          window_model <- Arima(window_data, order = arima_order[1:3])
          
          # Extract coefficients
          if (!is.null(window_model$coef)) {
            param_results[[i]] <- list(
              window_size = window_ends[i],
              params = as.list(window_model$coef)
            )
          }
        }, error = function(e) {
          # Skip this window if model fitting fails
        })
      }
      
      # Check if we have results
      if (length(param_results) == 0) {
        return(
          plot_ly() %>%
            layout(
              title = "Could not analyze parameter stability",
              annotations = list(
                x = 0.5,
                y = 0.5,
                text = "Failed to fit models on data windows",
                showarrow = FALSE,
                font = list(size = 16)
              )
            )
        )
      }
      
      # Extract parameter names and create data frame
      param_names <- names(param_results[[1]]$params)
      param_stability_df <- data.frame(
        window_size = sapply(param_results, function(x) x$window_size)
      )
      
      for (param in param_names) {
        param_stability_df[[param]] <- sapply(param_results, function(x) {
          if (param %in% names(x$params)) x$params[[param]] else NA
        })
      }
      
      # Create plot
      p <- plot_ly()
      
      colors <- c('#3c8dbc', '#00a65a', '#f39c12', '#dd4b39', '#605ca8')
      
      for (i in 1:length(param_names)) {
        param <- param_names[i]
        color_idx <- (i - 1) %% length(colors) + 1
        
        p <- p %>%
          add_trace(
            data = param_stability_df,
            x = ~window_size,
            y = as.formula(paste0("~", param)),
            type = 'scatter',
            mode = 'lines+markers',
            name = param,
            line = list(color = colors[color_idx], width = 2),
            marker = list(color = colors[color_idx], size = 6)
          )
      }
      
      p <- p %>%
        layout(
          title = "Parameter Stability Analysis",
          xaxis = list(title = "Training Window Size (observations)"),
          yaxis = list(title = "Parameter Value"),
          showlegend = TRUE
        )
      
      return(p)
      
    } else if (input$method == "Exponential Smoothing") {
      # Similar approach for ETS models
      item_data <- rv$processed_data %>%
        filter(Item_Name == input$diagnostics_item) %>%
        arrange(Date)
      
      ts_data <- ts(item_data$Volume, frequency = as.numeric(input$frequency))
      
      # For ETS, use the same model type for different windows
      ets_type <- model$method
      
      # Create windows
      num_windows <- 10
      min_window_size <- max(30, length(ts_data) * 0.3)
      
      if (length(ts_data) <= min_window_size) {
        return(
          plot_ly() %>%
            layout(
              title = "Insufficient data for parameter stability analysis",
              annotations = list(
                x = 0.5,
                y = 0.5,
                text = "Need more data points to analyze parameter stability",
                showarrow = FALSE,
                font = list(size = 16)
              )
            )
        )
      }
      
      window_ends <- floor(seq(min_window_size, length(ts_data), length.out = num_windows))
      
      # Prepare result storage
      param_results <- list()
      
      # Fit model on each window
      for (i in 1:length(window_ends)) {
        window_data <- ts_data[1:window_ends[i]]
        
        tryCatch({
          window_model <- ets(window_data, model = ets_type)
          
          # Extract parameters
          param_results[[i]] <- list(
            window_size = window_ends[i],
            params = as.list(window_model$par)
          )
        }, error = function(e) {
          # Skip this window if model fitting fails
        })
      }
      
      # Check if we have results
      if (length(param_results) == 0) {
        return(
          plot_ly() %>%
            layout(
              title = "Could not analyze parameter stability",
              annotations = list(
                x = 0.5,
                y = 0.5,
                text = "Failed to fit models on data windows",
                showarrow = FALSE,
                font = list(size = 16)
              )
            )
        )
      }
      
      # Extract parameter names and create data frame
      param_names <- names(param_results[[1]]$params)
      param_stability_df <- data.frame(
        window_size = sapply(param_results, function(x) x$window_size)
      )
      
      for (param in param_names) {
        param_stability_df[[param]] <- sapply(param_results, function(x) {
          if (param %in% names(x$params)) x$params[[param]] else NA
        })
      }
      
      # Create plot
      p <- plot_ly()
      
      colors <- c('#3c8dbc', '#00a65a', '#f39c12', '#dd4b39', '#605ca8')
      
      for (i in 1:length(param_names)) {
        param <- param_names[i]
        color_idx <- (i - 1) %% length(colors) + 1
        
        p <- p %>%
          add_trace(
            data = param_stability_df,
            x = ~window_size,
            y = as.formula(paste0("~", param)),
            type = 'scatter',
            mode = 'lines+markers',
            name = param,
            line = list(color = colors[color_idx], width = 2),
            marker = list(color = colors[color_idx], size = 6)
          )
      }
      
      p <- p %>%
        layout(
          title = "Parameter Stability Analysis",
          xaxis = list(title = "Training Window Size (observations)"),
          yaxis = list(title = "Parameter Value"),
          showlegend = TRUE
        )
      
      return(p)
      
    } else if (input$method == "Prophet") {
      # For Prophet, we'll focus on trend and seasonality parameters
      if ("model" %in% names(model) && !is.null(model$forecast)) {
        # Get data for item
        item_data <- rv$processed_data %>%
          filter(Item_Name == input$diagnostics_item) %>%
          arrange(Date)
        
        # Create windows similar to other methods
        num_windows <- 5 # Fewer windows because Prophet is slower
        min_window_size <- max(30, nrow(item_data) * 0.3)
        
        if (nrow(item_data) <= min_window_size) {
          return(
            plot_ly() %>%
              layout(
                title = "Insufficient data for parameter stability analysis",
                annotations = list(
                  x = 0.5,
                  y = 0.5,
                  text = "Need more data points to analyze parameter stability",
                  showarrow = FALSE,
                  font = list(size = 16)
                )
              )
          )
        }
        
        window_ends <- floor(seq(min_window_size, nrow(item_data), length.out = num_windows))
        
        # We'll focus on trend parameters for Prophet
        # Extract trend changepoints and their effects
        prophet_forecast <- model$forecast
        changepoints <- model$model$changepoints
        
        if (is.null(changepoints) || length(changepoints) == 0) {
          return(
            plot_ly() %>%
              layout(
                title = "No changepoints detected in Prophet model",
                annotations = list(
                  x = 0.5,
                  y = 0.5,
                  text = "The model does not have any trend changepoints to analyze",
                  showarrow = FALSE,
                  font = list(size = 16)
                )
              )
          )
        }
        
        # Create a data frame of changepoints and their effects
        cp_effects <- model$model$params$delta
        
        if (is.null(cp_effects) || length(cp_effects) == 0) {
          return(
            plot_ly() %>%
              layout(
                title = "Changepoint effects not available",
                annotations = list(
                  x = 0.5,
                  y = 0.5,
                  text = "Cannot extract changepoint effects from the model",
                  showarrow = FALSE,
                  font = list(size = 16)
                )
              )
          )
        }
        
        cp_df <- data.frame(
          date = as.Date(changepoints),
          effect = as.numeric(cp_effects)
        )
        
        # Calculate cumulative effect
        cp_df$cumulative_effect <- cumsum(cp_df$effect)
        
        # Plot changepoint effects
        p <- plot_ly() %>%
          add_trace(
            data = cp_df,
            x = ~date,
            y = ~effect,
            type = 'bar',
            name = 'Changepoint Effect',
            marker = list(color = '#3c8dbc')
          ) %>%
          add_trace(
            data = cp_df,
            x = ~date,
            y = ~cumulative_effect,
            type = 'scatter',
            mode = 'lines+markers',
            name = 'Cumulative Effect',
            yaxis = 'y2',
            line = list(color = '#00a65a', width = 2),
            marker = list(color = '#00a65a', size = 6)
          ) %>%
          layout(
            title = "Prophet Trend Changepoints",
            xaxis = list(title = "Date"),
            yaxis = list(title = "Individual Effect"),
            yaxis2 = list(
              title = "Cumulative Effect",
              overlaying = "y",
              side = "right"
            ),
            showlegend = TRUE
          )
        
        return(p)
      } else {
        return(
          plot_ly() %>%
            layout(
              title = "Prophet model details not available",
              annotations = list(
                x = 0.5,
                y = 0.5,
                text = "Cannot analyze parameter stability for this model",
                showarrow = FALSE,
                font = list(size = 16)
              )
            )
        )
      }
    }
  })
  
  # ===== Seasonality Plot =====
  output$seasonality_plot <- renderPlotly({
    req(rv$processed_data, input$diagnostics_item)
    
    # Get data for selected item
    item_data <- rv$processed_data %>%
      filter(Item_Name == input$diagnostics_item) %>%
      arrange(Date)
    
    # Check if we have enough data
    freq <- as.numeric(input$frequency)
    min_periods <- max(2 * freq, 30) # Need at least 2 full periods
    
    if (nrow(item_data) < min_periods) {
      return(
        plot_ly() %>%
          layout(
            title = "Insufficient data for seasonality analysis",
            annotations = list(
              x = 0.5,
              y = 0.5,
              text = paste("Need at least", min_periods, "observations for proper seasonality analysis"),
              showarrow = FALSE,
              font = list(size = 16)
            )
          )
      )
    }
    
    # Create time series object
    ts_data <- ts(item_data$Volume, frequency = freq)
    
    # Extract model if available
    model <- rv$model_objects[[input$diagnostics_item]]
    
    # Create seasonal subseries plot
    if (freq > 1) {
      # This is a proper seasonal time series
      
      # For Prophet, we can extract seasonal components directly
      if (!is.null(model) && input$method == "Prophet" && "model" %in% names(model) && !is.null(model$forecast)) {
        prophet_forecast <- model$forecast
        
        # Check which seasonality components exist
        seasonal_components <- c()
        if ("yearly" %in% colnames(prophet_forecast)) seasonal_components <- c(seasonal_components, "yearly")
        if ("weekly" %in% colnames(prophet_forecast)) seasonal_components <- c(seasonal_components, "weekly")
        if ("daily" %in% colnames(prophet_forecast)) seasonal_components <- c(seasonal_components, "daily")
        
        if (length(seasonal_components) == 0) {
          return(
            plot_ly() %>%
              layout(
                title = "No seasonality components detected",
                annotations = list(
                  x = 0.5,
                  y = 0.5,
                  text = "The Prophet model did not identify any significant seasonality",
                  showarrow = FALSE,
                  font = list(size = 16)
                )
              )
          )
        }
        
        # Create plot
        p <- plot_ly()
        
        # Add trace for each component
        colors <- c('#3c8dbc', '#00a65a', '#f39c12')
        
        for (i in 1:length(seasonal_components)) {
          component <- seasonal_components[i]
          
          # Prepare data for seasonal pattern
          if (component == "yearly") {
            # Group by day of year
            dates <- as.Date(prophet_forecast$ds)
            day_of_year <- as.numeric(format(dates, "%j"))
            
            seasonal_df <- data.frame(
              x = day_of_year,
              y = prophet_forecast[[component]],
              date = dates
            ) %>%
              arrange(x)
            
            x_title <- "Day of Year"
          } else if (component == "weekly") {
            # Group by day of week
            dates <- as.Date(prophet_forecast$ds)
            day_of_week <- as.numeric(format(dates, "%u"))
            
            seasonal_df <- data.frame(
              x = day_of_week,
              y = prophet_forecast[[component]],
              date = dates
            ) %>%
              arrange(x)
            
            x_title <- "Day of Week"
          } else if (component == "daily") {
            # Group by hour (if available)
            dates <- as.Date(prophet_forecast$ds)
            
            seasonal_df <- data.frame(
              x = 1:length(prophet_forecast[[component]]),
              y = prophet_forecast[[component]],
              date = dates
            ) %>%
              arrange(x)
            
            x_title <- "Hour of Day"
          }
          
          p <- p %>%
            add_trace(
              data = seasonal_df,
              x = ~x,
              y = ~y,
              type = 'scatter',
              mode = 'lines',
              name = paste(component, "Seasonality"),
              line = list(color = colors[i], width = 2)
            )
        }
        
        p <- p %>%
          layout(
            title = "Prophet Seasonality Components",
            xaxis = list(title = x_title),
            yaxis = list(title = "Seasonal Effect"),
            showlegend = TRUE
          )
        
        return(p)
        
      } else {
        # For other methods, use seasonal decomposition
        tryCatch({
          # Use STL decomposition
          stl_result <- stl(ts_data, s.window = "periodic")
          
          # Extract seasonal component
          seasonal_comp <- stl_result$time.series[, "seasonal"]
          
          # Convert to data frame for plotting
          seasonal_df <- data.frame(
            date = item_data$Date,
            seasonal = as.numeric(seasonal_comp),
            period = cycle(ts_data)
          )
          
          # Create seasonal subseries plot
          # Group by period (e.g., month for monthly data)
          period_groups <- unique(seasonal_df$period)
          
          # Create a plot with a line for each period
          mean_by_period <- aggregate(seasonal ~ period, seasonal_df, mean)
          
          # Plot
          p <- plot_ly()
          
          # Add trace for each instance of the period
          periods_per_year <- freq
          years <- floor(nrow(item_data) / periods_per_year)
          
          for (year in 1:min(years, 5)) { # Limit to 5 years for clarity
            start_idx <- (year - 1) * periods_per_year + 1
            end_idx <- min(year * periods_per_year, nrow(seasonal_df))
            
            if (end_idx > start_idx) {
              year_data <- seasonal_df[start_idx:end_idx, ]
              
              p <- p %>%
                add_trace(
                  data = year_data,
                  x = ~period,
                  y = ~seasonal,
                  type = 'scatter',
                  mode = 'lines+markers',
                  name = paste("Year", year),
                  line = list(dash = 'dash'),
                  marker = list(size = 6)
                )
            }
          }
          
          # Add average line
          p <- p %>%
            add_trace(
              data = mean_by_period,
              x = ~period,
              y = ~seasonal,
              type = 'scatter',
              mode = 'lines+markers',
              name = "Average",
              line = list(color = '#00a65a', width = 3),
              marker = list(color = '#00a65a', size = 8)
            )
          
          # Set layout
          p <- p %>%
            layout(
              title = "Seasonal Pattern Analysis",
              xaxis = list(
                title = "Period of Year",
                tickvals = period_groups,
                ticktext = period_groups
              ),
              yaxis = list(title = "Seasonal Component"),
              showlegend = TRUE
            )
          
          return(p)
          
        }, error = function(e) {
          return(
            plot_ly() %>%
              layout(
                title = "Error in seasonality analysis",
                annotations = list(
                  x = 0.5,
                  y = 0.5,
                  text = paste("Error:", e$message),
                  showarrow = FALSE,
                  font = list(size = 16)
                )
              )
          )
        })
      }
    } else {
      # Non-seasonal time series, show periodogram
      tryCatch({
        # Calculate periodogram
        spec <- spectrum(ts_data, plot = FALSE)
        
        # Convert to data frame
        period_df <- data.frame(
          frequency = spec$freq,
          period = 1 / spec$freq,
          spectrum = spec$spec
        )
        
        # Plot
        p <- plot_ly(
          data = period_df,
          x = ~period,
          y = ~spectrum,
          type = 'scatter',
          mode = 'lines',
          line = list(color = '#3c8dbc', width = 2),
          name = "Spectrum"
        ) %>%
          layout(
            title = "Periodogram Analysis",
            xaxis = list(
              title = "Period (days)",
              type = "log"
            ),
            yaxis = list(title = "Spectral Density"),
            showlegend = FALSE
          )
        
        return(p)
        
      }, error = function(e) {
        return(
          plot_ly() %>%
            layout(
              title = "Error in periodogram analysis",
              annotations = list(
                x = 0.5,
                y = 0.5,
                text = paste("Error:", e$message),
                showarrow = FALSE,
                font = list(size = 16)
              )
            )
        )
      })
    }
  })
  
  # ===== Seasonal Patterns =====
  output$seasonal_patterns <- renderPrint({
    req(rv$processed_data, input$diagnostics_item)
    
    # Get data for selected item
    item_data <- rv$processed_data %>%
      filter(Item_Name == input$diagnostics_item) %>%
      arrange(Date)
    
    # Check if we have enough data
    freq <- as.numeric(input$frequency)
    min_periods <- max(2 * freq, 30) # Need at least 2 full periods
    
    if (nrow(item_data) < min_periods) {
      cat("Insufficient data for seasonality analysis\n")
      cat("Need at least", min_periods, "observations for proper analysis\n")
      return()
    }
    
    # Create time series object
    ts_data <- ts(item_data$Volume, frequency = freq)
    
    # Extract model if available
    model <- rv$model_objects[[input$diagnostics_item]]
    
    # Analyze seasonality
    cat("Seasonality Analysis for", input$diagnostics_item, "\n\n")
    
    if (freq > 1) {
      # This is a proper seasonal time series
      
      # For Prophet, we can report seasonal components directly
      if (!is.null(model) && input$method == "Prophet" && "model" %in% names(model) && !is.null(model$forecast)) {
        prophet_forecast <- model$forecast
        
        # Check which seasonality components exist
        cat("Prophet Seasonality Components:\n\n")
        
        if ("yearly" %in% colnames(prophet_forecast)) {
          yearly_mean <- mean(prophet_forecast$yearly, na.rm = TRUE)
          yearly_sd <- sd(prophet_forecast$yearly, na.rm = TRUE)
          yearly_range <- max(prophet_forecast$yearly, na.rm = TRUE) - min(prophet_forecast$yearly, na.rm = TRUE)
          
          cat("Yearly Seasonality:\n")
          cat("- Mean Effect:", round(yearly_mean, 2), "\n")
          cat("- Standard Deviation:", round(yearly_sd, 2), "\n")
          cat("- Range:", round(yearly_range, 2), "\n")
          cat("- Relative Magnitude:", round(yearly_range / mean(prophet_forecast$trend, na.rm = TRUE) * 100, 2), "% of trend\n\n")
        }
        
        if ("weekly" %in% colnames(prophet_forecast)) {
          weekly_mean <- mean(prophet_forecast$weekly, na.rm = TRUE)
          weekly_sd <- sd(prophet_forecast$weekly, na.rm = TRUE)
          weekly_range <- max(prophet_forecast$weekly, na.rm = TRUE) - min(prophet_forecast$weekly, na.rm = TRUE)
          
          cat("Weekly Seasonality:\n")
          cat("- Mean Effect:", round(weekly_mean, 2), "\n")
          cat("- Standard Deviation:", round(weekly_sd, 2), "\n")
          cat("- Range:", round(weekly_range, 2), "\n")
          cat("- Relative Magnitude:", round(weekly_range / mean(prophet_forecast$trend, na.rm = TRUE) * 100, 2), "% of trend\n\n")
          
          # Check day of week pattern
          dates <- as.Date(prophet_forecast$ds)
          weekdays_df <- data.frame(
            weekday = weekdays(dates, abbreviate = TRUE),
            effect = prophet_forecast$weekly
          )
          
          weekday_means <- aggregate(effect ~ weekday, weekdays_df, mean)
          weekday_means <- weekday_means[order(weekday_means$effect, decreasing = TRUE), ]
          
          cat("Day of Week Pattern:\n")
          for (i in 1:nrow(weekday_means)) {
            cat("- ", weekday_means$weekday[i], ": ", round(weekday_means$effect[i], 2), "\n", sep = "")
          }
          cat("\n")
        }
        
        if ("daily" %in% colnames(prophet_forecast)) {
          daily_mean <- mean(prophet_forecast$daily, na.rm = TRUE)
          daily_sd <- sd(prophet_forecast$daily, na.rm = TRUE)
          daily_range <- max(prophet_forecast$daily, na.rm = TRUE) - min(prophet_forecast$daily, na.rm = TRUE)
          
          cat("Daily Seasonality:\n")
          cat("- Mean Effect:", round(daily_mean, 2), "\n")
          cat("- Standard Deviation:", round(daily_sd, 2), "\n")
          cat("- Range:", round(daily_range, 2), "\n")
          cat("- Relative Magnitude:", round(daily_range / mean(prophet_forecast$trend, na.rm = TRUE) * 100, 2), "% of trend\n\n")
        }
        
        if (!any(c("yearly", "weekly", "daily") %in% colnames(prophet_forecast))) {
          cat("No significant seasonality components detected by Prophet\n\n")
        }
        
      } else {
        # For other methods, use time series decomposition
        tryCatch({
          # Use STL decomposition
          stl_result <- stl(ts_data, s.window = "periodic")
          
          # Extract components
          trend_comp <- stl_result$time.series[, "trend"]
          seasonal_comp <- stl_result$time.series[, "seasonal"]
          remainder_comp <- stl_result$time.series[, "remainder"]
          
          # Calculate basic stats
          seasonal_mean <- mean(seasonal_comp, na.rm = TRUE)
          seasonal_sd <- sd(seasonal_comp, na.rm = TRUE)
          seasonal_range <- max(seasonal_comp, na.rm = TRUE) - min(seasonal_comp, na.rm = TRUE)
          
          cat("Time Series Decomposition (STL):\n\n")
          
          cat("Seasonal Component:\n")
          cat("- Mean:", round(seasonal_mean, 2), "\n")
          cat("- Standard Deviation:", round(seasonal_sd, 2), "\n")
          cat("- Range:", round(seasonal_range, 2), "\n")
          cat("- Relative Magnitude:", round(seasonal_range / mean(trend_comp, na.rm = TRUE) * 100, 2), "% of trend\n\n")
          
          # Analyze by period
          seasonal_df <- data.frame(
            date = item_data$Date,
            seasonal = as.numeric(seasonal_comp),
            period = cycle(ts_data)
          )
          
          # Calculate average by period
          period_means <- aggregate(seasonal ~ period, seasonal_df, mean)
          period_means <- period_means[order(period_means$seasonal, decreasing = TRUE), ]
          
          cat("Seasonal Pattern by Period:\n")
          for (i in 1:nrow(period_means)) {
            cat("- Period", period_means$period[i], ":", round(period_means$seasonal[i], 2), "\n")
          }
          
          # Test for significant seasonality
          seasonal_f_test <- friedman.test(seasonal_comp ~ cycle(ts_data))
          cat("\nFriedman Test for Seasonality:\n")
          cat("- Chi-squared:", round(seasonal_f_test$statistic, 4), "\n")
          cat("- p-value:", format.pval(seasonal_f_test$p.value, digits = 4), "\n")
          cat("- Interpretation:", ifelse(seasonal_f_test$p.value < 0.05, 
                                          "Significant seasonality detected",
                                          "No significant seasonality detected"), "\n")
          
        }, error = function(e) {
          cat("Error in seasonality analysis:", e$message, "\n")
        })
      }
    } else {
      # Non-seasonal time series, report results from periodogram
      cat("Periodogram Analysis (frequency = 1):\n\n")
      
      tryCatch({
        # Calculate periodogram
        spec <- spectrum(ts_data, plot = FALSE)
        
        # Find top peaks
        period_df <- data.frame(
          frequency = spec$freq,
          period = 1 / spec$freq,
          spectrum = spec$spec
        )
        
        # Sort by spectrum power
        period_df <- period_df[order(period_df$spectrum, decreasing = TRUE), ]
        
        # Report top periods
        cat("Top Periodic Components:\n")
        for (i in 1:min(5, nrow(period_df))) {
          cat("- Period of", round(period_df$period[i], 2), "days (frequency =", 
              round(period_df$frequency[i], 4), ") with power =", 
              round(period_df$spectrum[i], 2), "\n")
        }
        
        # Test for significant periodicity
        cat("\nNo clear seasonal pattern detected with provided frequency settings\n")
        cat("Consider changing the frequency parameter to match your data\n")
        
      }, error = function(e) {
        cat("Error in periodogram analysis:", e$message, "\n")
      })
    }
  })
  
  # ===== Seasonal Strength =====
  output$seasonal_strength <- renderPrint({
    req(rv$processed_data, input$diagnostics_item)
    
    # Get data for selected item
    item_data <- rv$processed_data %>%
      filter(Item_Name == input$diagnostics_item) %>%
      arrange(Date)
    
    # Check if we have enough data
    freq <- as.numeric(input$frequency)
    min_periods <- max(2 * freq, 30)
    
    if (nrow(item_data) < min_periods) {
      cat("Insufficient data for seasonality strength analysis\n")
      return()
    }
    
    # Create time series object
    ts_data <- ts(item_data$Volume, frequency = freq)
    
    cat("Seasonality Strength Metrics for", input$diagnostics_item, "\n\n")
    
    if (freq > 1) {
      # Use decomposition to measure strength
      tryCatch({
        # STL decomposition
        stl_result <- stl(ts_data, s.window = "periodic")
        
        # Extract components
        trend_comp <- stl_result$time.series[, "trend"]
        seasonal_comp <- stl_result$time.series[, "seasonal"]
        remainder_comp <- stl_result$time.series[, "remainder"]
        
        # Calculate strength measures
        # Formula: 1 - Var(Remainder) / Var(Seasonal + Remainder)
        var_remainder <- var(remainder_comp, na.rm = TRUE)
        var_seasonality <- var(seasonal_comp, na.rm = TRUE)
        var_combo <- var(seasonal_comp + remainder_comp, na.rm = TRUE)
        
        seasonal_strength <- max(0, 1 - var_remainder / var_combo)
        
        # Calculate trend strength
        # Formula: 1 - Var(Remainder) / Var(Trend + Remainder)
        var_trend <- var(trend_comp, na.rm = TRUE)
        var_deseason <- var(trend_comp + remainder_comp, na.rm = TRUE)
        
        trend_strength <- max(0, 1 - var_remainder / var_deseason)
        
        # Report results
        cat("STL Decomposition Strength Measures:\n\n")
        
        cat("Seasonality Strength:", round(seasonal_strength, 4), "\n")
        cat("  (", 
            ifelse(seasonal_strength < 0.2, "Weak", 
                   ifelse(seasonal_strength < 0.5, "Moderate", "Strong")), 
            " seasonal pattern)\n\n", sep = "")
        
        cat("Trend Strength:", round(trend_strength, 4), "\n")
        cat("  (", 
            ifelse(trend_strength < 0.2, "Weak", 
                   ifelse(trend_strength < 0.5, "Moderate", "Strong")), 
            " trend pattern)\n\n", sep = "")
        
        # Additional measures
        seasonal_contribution <- var_seasonality / (var_seasonality + var_trend + var_remainder)
        trend_contribution <- var_trend / (var_seasonality + var_trend + var_remainder)
        noise_contribution <- var_remainder / (var_seasonality + var_trend + var_remainder)
        
        cat("Component Variance Contributions:\n")
        cat("- Seasonal Component:", round(seasonal_contribution * 100, 2), "%\n")
        cat("- Trend Component:", round(trend_contribution * 100, 2), "%\n")
        cat("- Remainder (Noise):", round(noise_contribution * 100, 2), "%\n")
        
        # Autocorrelation test at seasonal lags
        seasonal_lag <- freq
        acf_results <- acf(remainder_comp, lag.max = seasonal_lag, plot = FALSE)
        seasonal_autocorr <- acf_results$acf[seasonal_lag + 1] # +1 because lag 0 is included
        
        cat("\nResidual Autocorrelation at Seasonal Lag (", seasonal_lag, "):", round(seasonal_autocorr, 4), "\n", sep = "")
        cat("Interpretation: ", ifelse(abs(seasonal_autocorr) < 0.2, 
                                       "Minimal residual seasonality",
                                       "Some residual seasonality may remain"), "\n")
        
      }, error = function(e) {
        cat("Error in seasonality strength analysis:", e$message, "\n")
      })
    } else {
      cat("Seasonality strength analysis requires frequency > 1\n")
      cat("Current frequency setting is 1 (non-seasonal)\n")
      cat("Consider adjusting the frequency parameter to match your data's seasonality\n")
    }
  })
  
  # ===== Forecast Error Plot =====
  output$forecast_error_plot <- renderPlotly({
    req(rv$processed_data, rv$forecast_results, input$diagnostics_item)
    
    # Check if we have performance metrics
    if (is.null(rv$performance_metrics) || 
        is.null(rv$performance_metrics[[input$diagnostics_item]])) {
      return(
        plot_ly() %>%
          layout(
            title = "Forecast evaluation not available",
            annotations = list(
              x = 0.5,
              y = 0.5,
              text = "No performance metrics available for this item",
              showarrow = FALSE,
              font = list(size = 16)
            )
          )
      )
    }
    
    # Get data
    item_data <- rv$processed_data %>%
      filter(Item_Name == input$diagnostics_item) %>%
      arrange(Date)
    
    # We need to re-calculate prediction errors by comparing forecasts with actuals
    # This would typically be done using a validation set approach
    
    # Extract forecast results
    forecast_data <- rv$forecast_results %>%
      filter(Item_Name == input$diagnostics_item)
    
    
    # Get model object
    model <- rv$model_objects[[input$diagnostics_item]]
    
    # For proper evaluation, we should use a testing approach
    # Let's use the validation metrics
    metrics <- rv$performance_metrics[[input$diagnostics_item]]
    
    # Create a plot showing the error distribution and statistics
    p <- plot_ly() %>%
      add_trace(
        x = c("MAE", "RMSE", "MAPE"),
        y = c(metrics$MAE, metrics$RMSE, metrics$MAPE / 100 * mean(item_data$Volume, na.rm = TRUE)), # Scale MAPE to be comparable
        type = 'bar',
        marker = list(color = c('#3c8dbc', '#00a65a', '#f39c12')),
        name = 'Error Metrics'
      ) %>%
      layout(
        title = paste("Forecast Error Metrics for", input$diagnostics_item),
        xaxis = list(title = "Metric"),
        yaxis = list(title = "Value"),
        showlegend = FALSE
      )
    
    return(p)
  })
  
  # ===== Error Distribution =====
  output$error_distribution <- renderPlotly({
    req(rv$processed_data, rv$model_objects, input$diagnostics_item)
    
    # Get model object for selected item
    model <- rv$model_objects[[input$diagnostics_item]]
    
    if (is.null(model)) {
      return(
        plot_ly() %>%
          layout(
            title = "No model available",
            annotations = list(
              x = 0.5,
              y = 0.5,
              text = "No model found for the selected item",
              showarrow = FALSE,
              font = list(size = 16)
            )
          )
      )
    }
    
    # Extract residuals or errors
    errors <- NULL
    
    if (input$method == "ARIMA" || input$method == "Exponential Smoothing") {
      errors <- as.numeric(residuals(model))
    } else if (input$method == "Prophet") {
      # Calculate errors as before
      if ("model" %in% names(model) && !is.null(model$forecast)) {
        prophet_forecast <- model$forecast
        item_data <- rv$processed_data %>%
          filter(Item_Name == input$diagnostics_item) %>%
          arrange(Date)
        
        common_dates <- intersect(as.Date(prophet_forecast$ds), item_data$Date)
        
        if (length(common_dates) > 0) {
          forecast_subset <- prophet_forecast %>%
            filter(as.Date(ds) %in% common_dates) %>%
            select(ds, yhat)
          
          actual_subset <- item_data %>%
            filter(Date %in% common_dates) %>%
            select(Date, Volume)
          
          errors_df <- inner_join(
            forecast_subset %>% mutate(ds = as.Date(ds)),
            actual_subset,
            by = c("ds" = "Date")
          ) %>%
            mutate(Error = Volume - yhat)
          
          errors <- errors_df$Error
        }
      }
    }
    
    if (is.null(errors) || length(errors) == 0) {
      return(
        plot_ly() %>%
          layout(
            title = "No errors available for analysis",
            annotations = list(
              x = 0.5,
              y = 0.5,
              text = "Could not extract model errors",
              showarrow = FALSE,
              font = list(size = 16)
            )
          )
      )
    }
    
    # Create error distribution plot
    p <- plot_ly(
      x = errors,
      type = 'histogram',
      nbinsx = 30,
      marker = list(color = '#3c8dbc'),
      name = 'Error Distribution'
    ) %>%
      layout(
        title = "Distribution of Forecast Errors",
        xaxis = list(title = "Error"),
        yaxis = list(title = "Frequency"),
        showlegend = FALSE,
        shapes = list(
          # Add vertical line at mean
          list(
            type = 'line',
            x0 = mean(errors, na.rm = TRUE),
            x1 = mean(errors, na.rm = TRUE),
            y0 = 0,
            y1 = 1,
            yref = 'paper',
            line = list(color = '#f39c12', width = 2, dash = 'dash')
          ),
          # Add vertical line at zero
          list(
            type = 'line',
            x0 = 0,
            x1 = 0,
            y0 = 0,
            y1 = 1,
            yref = 'paper',
            line = list(color = '#00a65a', width = 2)
          )
        ),
        annotations = list(
          list(
            x = mean(errors, na.rm = TRUE),
            y = 1,
            yref = 'paper',
            text = paste("Mean:", round(mean(errors, na.rm = TRUE), 2)),
            showarrow = TRUE,
            arrowhead = 7,
            ax = 0,
            ay = -40
          )
        )
      )
    
    return(p)
  })
  
  # ===== Error Statistics =====
  output$error_stats <- renderPrint({
    req(rv$processed_data, rv$model_objects, input$diagnostics_item)
    
    # Get model object for selected item
    model <- rv$model_objects[[input$diagnostics_item]]
    
    if (is.null(model)) {
      cat("No model available for", input$diagnostics_item)
      return()
    }
    
    # Extract errors
    errors <- NULL
    
    if (input$method == "ARIMA" || input$method == "Exponential Smoothing") {
      errors <- as.numeric(residuals(model))
    } else if (input$method == "Prophet") {
      # Calculate errors as before
      if ("model" %in% names(model) && !is.null(model$forecast)) {
        prophet_forecast <- model$forecast
        item_data <- rv$processed_data %>%
          filter(Item_Name == input$diagnostics_item) %>%
          arrange(Date)
        
        common_dates <- intersect(as.Date(prophet_forecast$ds), item_data$Date)
        
        if (length(common_dates) > 0) {
          forecast_subset <- prophet_forecast %>%
            filter(as.Date(ds) %in% common_dates) %>%
            select(ds, yhat)
          
          actual_subset <- item_data %>%
            filter(Date %in% common_dates) %>%
            select(Date, Volume)
          
          errors_df <- inner_join(
            forecast_subset %>% mutate(ds = as.Date(ds)),
            actual_subset,
            by = c("ds" = "Date")
          ) %>%
            mutate(Error = Volume - yhat)
          
          errors <- errors_df$Error
        }
      }
    }
    
    if (is.null(errors) || length(errors) == 0) {
      cat("No errors available for analysis")
      return()
    }
    
    # Calculate error statistics
    cat("Error Statistics:\n\n")
    
    cat("Sample Size:", length(errors), "\n\n")
    
    cat("Basic Statistics:\n")
    cat("Mean:", round(mean(errors, na.rm = TRUE), 4), "\n")
    cat("Standard Deviation:", round(sd(errors, na.rm = TRUE), 4), "\n")
    cat("Minimum:", round(min(errors, na.rm = TRUE), 4), "\n")
    cat("Maximum:", round(max(errors, na.rm = TRUE), 4), "\n\n")
    
    # Calculate quantiles
    error_quantiles <- quantile(errors, probs = c(0.025, 0.25, 0.5, 0.75, 0.975), na.rm = TRUE)
    
    cat("Percentiles:\n")
    cat("2.5%:", round(error_quantiles[1], 4), "\n")
    cat("25%:", round(error_quantiles[2], 4), "\n")
    cat("50% (Median):", round(error_quantiles[3], 4), "\n")
    cat("75%:", round(error_quantiles[4], 4), "\n")
    cat("97.5%:", round(error_quantiles[5], 4), "\n\n")
    
    # Get performance metrics
    if (!is.null(rv$performance_metrics) && !is.null(rv$performance_metrics[[input$diagnostics_item]])) {
      metrics <- rv$performance_metrics[[input$diagnostics_item]]
      
      cat("Performance Metrics:\n")
      cat("MAE:", metrics$MAE, "\n")
      cat("RMSE:", metrics$RMSE, "\n")
      cat("MAPE:", metrics$MAPE, "%\n\n")
    }
    
    # Check for bias
    t_test <- t.test(errors)
    
    cat("Test for Bias (t-test):\n")
    cat("t-statistic:", round(t_test$statistic, 4), "\n")
    cat("p-value:", format.pval(t_test$p.value, digits = 4), "\n")
    cat("Interpretation: ", ifelse(t_test$p.value > 0.05, 
                                   "No significant bias detected (errors centered at zero)",
                                   "Bias detected (errors not centered at zero)"), "\n")
  })
  
  # ===== Diagnostics Information =====
  output$diagnostics_info <- renderPrint({
    req(rv$processed_data, input$diagnostics_item)
    
    # Get data for selected item
    item_data <- rv$processed_data %>%
      filter(Item_Name == input$diagnostics_item) %>%
      arrange(Date)
    
    # Get model object
    model <- rv$model_objects[[input$diagnostics_item]]
    
    cat("Diagnostics Summary for", input$diagnostics_item, "\n\n")
    
    cat("Data Information:\n")
    cat("- Observations:", nrow(item_data), "\n")
    cat("- Date Range:", format(min(item_data$Date), "%Y-%m-%d"), "to", format(max(item_data$Date), "%Y-%m-%d"), "\n")
    cat("- Frequency Setting:", input$frequency, "\n\n")
    
    cat("Model Information:\n")
    cat("- Method:", input$method, "\n")
    
    if (!is.null(model)) {
      if (input$method == "ARIMA") {
        cat("- ARIMA Order:", paste(arimaorder(model), collapse = ","), "\n")
        cat("- AIC:", round(model$aic, 2), "\n")
      } else if (input$method == "Exponential Smoothing") {
        cat("- ETS Model:", model$method, "\n")
        cat("- AIC:", round(model$aic, 2), "\n")
      } else if (input$method == "Prophet") {
        if ("model" %in% names(model)) {
          cat("- Growth Type:", model$model$growth, "\n")
          cat("- Active Seasonality Components:", 
              paste(c(
                if (model$model$yearly.seasonality) "Yearly" else NULL,
                if (model$model$weekly.seasonality) "Weekly" else NULL,
                if (model$model$daily.seasonality) "Daily" else NULL
              ), collapse = ", "), "\n")
        }
      }
    } else {
      cat("- No model details available\n")
    }
    
    # Performance summary
    if (!is.null(rv$performance_metrics) && !is.null(rv$performance_metrics[[input$diagnostics_item]])) {
      metrics <- rv$performance_metrics[[input$diagnostics_item]]
      
      cat("\nPerformance Metrics:\n")
      cat("- MAE:", metrics$MAE, "\n")
      cat("- RMSE:", metrics$RMSE, "\n")
      cat("- MAPE:", metrics$MAPE, "%\n")
    } else {
      cat("\nNo performance metrics available\n")
    }
  })
  
  # ===== Model Comparison =====
  # When user clicks "Run Comparison" button
  observeEvent(input$run_comparison, {
    req(rv$processed_data, input$diagnostics_item)
    
    # Get data for selected item
    item_data <- rv$processed_data %>%
      filter(Item_Name == input$diagnostics_item) %>%
      arrange(Date)
    
    # Check if we have enough data
    if (nrow(item_data) < 30) {
      showNotification("Not enough data for model comparison", type = "error")
      return()
    }
    
    # Determine which models to compare
    models_to_compare <- c()
    if (input$compare_arima) models_to_compare <- c(models_to_compare, "ARIMA")
    if (input$compare_ets) models_to_compare <- c(models_to_compare, "ETS")
    if (input$compare_prophet) models_to_compare <- c(models_to_compare, "Prophet")
    
    if (length(models_to_compare) == 0) {
      showNotification("Please select at least one model to compare", type = "warning")
      return()
    }
    
    # Show progress
    withProgress(message = 'Comparing models...', value = 0, {
      
      # Create time series object
      ts_data <- ts(item_data$Volume, frequency = as.numeric(input$frequency))
      
      # Split into training and test
      test_size <- min(30, floor(nrow(item_data) / 4))
      train_size <- nrow(item_data) - test_size
      
      train_data <- head(item_data, train_size)
      test_data <- tail(item_data, test_size)
      
      ts_train <- ts(train_data$Volume, frequency = as.numeric(input$frequency))
      
      # Initialize results storage
      comparison_results <- data.frame(
        Model = character(),
        MAE = numeric(),
        RMSE = numeric(),
        MAPE = numeric(),
        AIC = numeric(),
        Training_Time = numeric(),
        stringsAsFactors = FALSE
      )
      
      # List to store forecast data frames
      forecast_list <- list()
      model_list <- list()
      
      # Step counter for progress
      total_steps <- length(models_to_compare)
      step_size <- 1 / total_steps
      
      # Fit and evaluate each model
      for (i in 1:length(models_to_compare)) {
        model_name <- models_to_compare[i]
        
        incProgress(step_size, detail = paste("Fitting", model_name))
        
        # Fit the model
        start_time <- Sys.time()
        
        tryCatch({
          if (model_name == "ARIMA") {
            # Fit ARIMA
            fit <- auto.arima(ts_train)
            
            # Generate forecast
            forecast_result <- forecast(fit, h = test_size)
            
            # Extract predictions
            predictions <- as.numeric(forecast_result$mean)
            
            # Calculate AIC
            model_aic <- fit$aic
            
            # Store model
            model_list[["ARIMA"]] <- fit
            
          } else if (model_name == "ETS") {
            # Fit ETS
            fit <- ets(ts_train)
            
            # Generate forecast
            forecast_result <- forecast(fit, h = test_size)
            
            # Extract predictions
            predictions <- as.numeric(forecast_result$mean)
            
            # Calculate AIC
            model_aic <- fit$aic
            
            # Store model
            model_list[["ETS"]] <- fit
            
          } else if (model_name == "Prophet") {
            # Prepare data for Prophet
            prophet_train <- data.frame(
              ds = train_data$Date,
              y = train_data$Volume
            )
            
            # Fit Prophet
            fit <- prophet(
              prophet_train,
              yearly.seasonality = 'auto',
              weekly.seasonality = 'auto',
              daily.seasonality = 'auto'
            )
            
            # Generate forecast
            future <- make_future_dataframe(fit, periods = test_size, freq = "day")
            forecast_result <- predict(fit, future)
            
            # Extract predictions
            predictions <- tail(forecast_result$yhat, test_size)
            
            # Prophet doesn't have AIC, use NA
            model_aic <- NA
            
            # Store model
            model_list[["Prophet"]] <- list(
              model = fit,
              forecast = forecast_result
            )
          }
          
          # Calculate training time
          end_time <- Sys.time()
          training_time <- as.numeric(difftime(end_time, start_time, units = "secs"))
          
          # Calculate performance metrics
          metrics <- calculate_metrics(test_data$Volume, predictions)
          
          # Store results
          comparison_results <- rbind(
            comparison_results,
            data.frame(
              Model = model_name,
              MAE = metrics$MAE,
              RMSE = metrics$RMSE,
              MAPE = metrics$MAPE,
              AIC = model_aic,
              Training_Time = round(training_time, 2),
              stringsAsFactors = FALSE
            )
          )
          
          # Store forecast for plotting
          forecast_dates <- test_data$Date
          
          forecast_list[[model_name]] <- data.frame(
            Date = forecast_dates,
            Forecast = predictions,
            Model = model_name
          )
          
        }, error = function(e) {
          showNotification(paste("Error fitting", model_name, ":", e$message), type = "error")
        })
      }
      
      # Combine all forecasts for plotting
      if (length(forecast_list) > 0) {
        all_forecasts <- do.call(rbind, forecast_list)
        
        # Add test data
        test_df <- data.frame(
          Date = test_data$Date,
          Forecast = test_data$Volume,
          Model = "Actual"
        )
        
        all_forecasts <- rbind(all_forecasts, test_df)
        
        # Store in reactive value for plotting
        rv$comparison_forecasts <- all_forecasts
        rv$comparison_models <- model_list
        rv$comparison_metrics <- comparison_results
        
        # Update UI elements
        output$comparison_plot <- renderPlotly({
          # Create line plot
          p <- plot_ly()
          
          # Add actual values
          p <- p %>% add_trace(
            data = test_df,
            x = ~Date,
            y = ~Forecast,
            type = 'scatter',
            mode = 'lines+markers',
            name = 'Actual',
            line = list(color = 'black', width = 2),
            marker = list(color = 'black', size = 6)
          )
          
          # Add each model's forecast
          colors <- c('#3c8dbc', '#00a65a', '#f39c12', '#dd4b39')
          
          for (i in 1:length(models_to_compare)) {
            model_name <- models_to_compare[i]
            color_idx <- i %% length(colors) + 1
            
            if (model_name %in% names(forecast_list)) {
              model_forecast <- forecast_list[[model_name]]
              
              p <- p %>% add_trace(
                data = model_forecast,
                x = ~Date,
                y = ~Forecast,
                type = 'scatter',
                mode = 'lines',
                name = model_name,
                line = list(color = colors[color_idx], width = 2, dash = 'dash')
              )
            }
          }
          
          # Layout
          p <- p %>% layout(
            title = paste("Model Comparison for", input$diagnostics_item),
            xaxis = list(title = "Date"),
            yaxis = list(title = "Volume"),
            showlegend = TRUE
          )
          
          return(p)
        })
        
        output$comparison_table <- renderDT({
          # Format results table
          comparison_display <- comparison_results
          
          # Format AIC column to handle NA values
          comparison_display$AIC <- sapply(comparison_display$AIC, function(x) {
            if (is.na(x)) return("N/A") else return(round(x, 2))
          })
          
          # Highlight best model for each metric
          datatable(
            comparison_display,
            options = list(pageLength = 10, dom = 't'),
            rownames = FALSE
          ) %>%
            formatStyle(
              'MAE',
              backgroundColor = styleEqual(min(comparison_results$MAE), '#d5f5e3')
            ) %>%
            formatStyle(
              'RMSE',
              backgroundColor = styleEqual(min(comparison_results$RMSE), '#d5f5e3')
            ) %>%
            formatStyle(
              'MAPE',
              backgroundColor = styleEqual(min(comparison_results$MAPE), '#d5f5e3')
            )
        })
        
        # Update diagnostic indicators based on comparison
        best_model <- comparison_results %>%
          filter(MAPE == min(MAPE)) %>%
          pull(Model)
        
        # Set badges
        shinyjs::html("residual_randomness_badge", 
                      ifelse(best_model == "ARIMA", "Good", 
                             ifelse(best_model == "ETS", "Moderate", "Good")))
        
        shinyjs::html("parameter_significance_badge", 
                      ifelse(best_model == "ARIMA", "Good", 
                             ifelse(best_model == "ETS", "Good", "Moderate")))
        
        shinyjs::html("forecast_accuracy_badge", 
                      ifelse(min(comparison_results$MAPE) < 10, "Good",
                             ifelse(min(comparison_results$MAPE) < 20, "Moderate", "Poor")))
        
        shinyjs::html("overall_fit_badge", 
                      ifelse(best_model == "ARIMA", "Good", 
                             ifelse(best_model == "ETS", "Good", 
                                    ifelse(best_model == "Prophet", "Good", "Moderate"))))
        
        # Set progress bars
        shinyjs::runjs(paste0("document.getElementById('residual_randomness_bar').style.width = '", 
                              ifelse(best_model == "ARIMA", "85", 
                                     ifelse(best_model == "ETS", "75", "80")), 
                              "%';"))
        
        shinyjs::runjs(paste0("document.getElementById('parameter_significance_bar').style.width = '", 
                              ifelse(best_model == "ARIMA", "85", 
                                     ifelse(best_model == "ETS", "80", "70")), 
                              "%';"))
        
        accuracy_pct <- 100 - min(comparison_results$MAPE) * 3
        accuracy_pct <- max(30, min(95, accuracy_pct))
        shinyjs::runjs(paste0("document.getElementById('forecast_accuracy_bar').style.width = '", 
                              accuracy_pct, "%';"))
        
        overall_pct <- ifelse(best_model == "ARIMA", 85, 
                              ifelse(best_model == "ETS", 80, 
                                     ifelse(best_model == "Prophet", 82, 75)))
        shinyjs::runjs(paste0("document.getElementById('overall_fit_bar').style.width = '", 
                              overall_pct, "%';"))
        
        # Update colors based on accuracy
        if (min(comparison_results$MAPE) < 10) {
          shinyjs::removeClass("forecast_accuracy_badge", "badge-warning")
          shinyjs::removeClass("forecast_accuracy_badge", "badge-danger")
          shinyjs::addClass("forecast_accuracy_badge", "badge-success")
          
          shinyjs::removeClass("forecast_accuracy_bar", "bg-warning")
          shinyjs::removeClass("forecast_accuracy_bar", "bg-danger")
          shinyjs::addClass("forecast_accuracy_bar", "bg-success")
        } else if (min(comparison_results$MAPE) < 20) {
          shinyjs::removeClass("forecast_accuracy_badge", "badge-success")
          shinyjs::removeClass("forecast_accuracy_badge", "badge-danger")
          shinyjs::addClass("forecast_accuracy_badge", "badge-warning")
          
          shinyjs::removeClass("forecast_accuracy_bar", "bg-success")
          shinyjs::removeClass("forecast_accuracy_bar", "bg-danger")
          shinyjs::addClass("forecast_accuracy_bar", "bg-warning")
        } else {
          shinyjs::removeClass("forecast_accuracy_badge", "badge-success")
          shinyjs::removeClass("forecast_accuracy_badge", "badge-warning")
          shinyjs::addClass("forecast_accuracy_badge", "badge-danger")
          
          shinyjs::removeClass("forecast_accuracy_bar", "bg-success")
          shinyjs::removeClass("forecast_accuracy_bar", "bg-warning")
          shinyjs::addClass("forecast_accuracy_bar", "bg-danger")
        }
      }
    })
  })
  
  # ===== Download Diagnostics Report =====
  output$download_diagnostics <- downloadHandler(
    filename = function() {
      paste0("diagnostics_", gsub(" ", "_", input$diagnostics_item), "_", 
             Sys.Date(), ".", input$export_diagnostics_format)
    },
    content = function(file) {
      # This would be implemented with R Markdown for generating reports
      # For now, just create a simple text/csv report
      
      # Get data
      item_data <- rv$processed_data %>%
        filter(Item_Name == input$diagnostics_item)
      
      # Get model
      model <- rv$model_objects[[input$diagnostics_item]]
      
      # Create some basic content
      if (input$export_diagnostics_format == "html") {
        # Simple HTML report
        html_content <- paste0(
          "<html><head><title>Diagnostics Report: ", input$diagnostics_item, "</title>",
          "<style>body{font-family:Arial;margin:20px;line-height:1.4} h1{color:#3c8dbc} h2{color:#00a65a} table{border-collapse:collapse;width:100%} th,td{text-align:left;padding:8px;border:1px solid #ddd} th{background-color:#f5f5f5}</style>",
          "</head><body>",
          "<h1>Diagnostics Report: ", input$diagnostics_item, "</h1>",
          "<p>Generated on ", Sys.Date(), "</p>",
          "<h2>Data Overview</h2>",
          "<p>Observations: ", nrow(item_data), "</p>",
          "<p>Date Range: ", format(min(item_data$Date), "%Y-%m-%d"), " to ", format(max(item_data$Date), "%Y-%m-%d"), "</p>",
          "<h2>Model Information</h2>",
          "<p>Method: ", input$method, "</p>"
        )
        
        # Add model details
        if (!is.null(model)) {
          if (input$method == "ARIMA") {
            html_content <- paste0(
              html_content,
              "<p>ARIMA Order: ", paste(arimaorder(model), collapse = ","), "</p>",
              "<p>AIC: ", round(model$aic, 2), "</p>"
            )
          } else if (input$method == "Exponential Smoothing") {
            html_content <- paste0(
              html_content,
              "<p>ETS Model: ", model$method, "</p>",
              "<p>AIC: ", round(model$aic, 2), "</p>"
            )
          }
        }
        
        # Add performance metrics
        if (!is.null(rv$performance_metrics) && !is.null(rv$performance_metrics[[input$diagnostics_item]])) {
          metrics <- rv$performance_metrics[[input$diagnostics_item]]
          
          html_content <- paste0(
            html_content,
            "<h2>Performance Metrics</h2>",
            "<table>",
            "<tr><th>Metric</th><th>Value</th></tr>",
            "<tr><td>MAE</td><td>", metrics$MAE, "</td></tr>",
            "<tr><td>RMSE</td><td>", metrics$RMSE, "</td></tr>",
            "<tr><td>MAPE</td><td>", metrics$MAPE, "%</td></tr>",
            "</table>"
          )
        }
        
        # Close the HTML
        html_content <- paste0(html_content, "</body></html>")
        
        # Write to file
        writeLines(html_content, file)
        
      } else if (input$export_diagnostics_format == "pdf") {
        # For PDF, we would use R Markdown
        # This is just a placeholder that creates a text file
        writeLines(paste("Diagnostics Report for", input$diagnostics_item, 
                         "\n\nThis is a placeholder. Full PDF report generation would be implemented with R Markdown."), 
                   file)
      } else if (input$export_diagnostics_format == "docx") {
        # Also a placeholder
        writeLines(paste("Diagnostics Report for", input$diagnostics_item, 
                         "\n\nThis is a placeholder. Full Word document generation would be implemented with R Markdown."), 
                   file)
      }
    }
  )
  
  # =====================
  # Help Tab Functions
  # =====================
  
  # Get Started button
  observeEvent(input$get_started, {
    # Switch to the Data tab
    updateTabItems(session, "sidebar", "data")
  })
  
  
}


# Run the app
shinyApp(ui = ui, server = server)
